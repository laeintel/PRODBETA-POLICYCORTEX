# Optimized workflow configuration for concurrent self-hosted runner execution
# This shows how to structure jobs for maximum parallelism

name: Concurrent Pipeline Example

on:
  push:
    branches: [main, develop]

# Enable concurrency control to allow multiple runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # Allow concurrent runs

jobs:
  # Jobs that can run in parallel immediately
  parallel-analysis:
    strategy:
      matrix:
        job-type: [lint, security-scan, dependency-check, code-quality]
      max-parallel: 4  # Run all 4 jobs simultaneously if runners available
    runs-on: self-hosted
    name: ${{ matrix.job-type }}
    steps:
      - uses: actions/checkout@v4
      - name: Run ${{ matrix.job-type }}
        run: |
          echo "Running ${{ matrix.job-type }} on runner: ${{ runner.name }}"
          # Your job-specific commands here

  # Service-specific tests (can run concurrently)
  service-tests:
    strategy:
      matrix:
        service: [api_gateway, azure_integration, ai_engine, data_processing, conversation, notification]
      max-parallel: 6  # All services can test simultaneously
    runs-on: self-hosted
    name: Test ${{ matrix.service }}
    steps:
      - uses: actions/checkout@v4
      - name: Test ${{ matrix.service }}
        run: |
          echo "Testing ${{ matrix.service }} on runner: ${{ runner.name }}"
          cd backend/services/${{ matrix.service }}
          # Your test commands here

  # Docker builds (requires Linux runners - separate from Windows jobs)
  docker-builds:
    if: github.event_name == 'push'
    strategy:
      matrix:
        service: [api_gateway, azure_integration, ai_engine, data_processing, conversation, notification]
      max-parallel: 6
    runs-on: ubuntu-latest  # Keep Docker on Linux
    name: Build ${{ matrix.service }} Image
    steps:
      - uses: actions/checkout@v4
      - name: Build Docker image for ${{ matrix.service }}
        run: |
          echo "Building Docker image for ${{ matrix.service }}"
          # Docker build commands here

  # Frontend jobs (can run on Windows)
  frontend-jobs:
    strategy:
      matrix:
        task: [build, test, lint, type-check]
      max-parallel: 4
    runs-on: self-hosted
    name: Frontend ${{ matrix.task }}
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Run frontend ${{ matrix.task }}
        run: |
          cd frontend
          npm ci
          npm run ${{ matrix.task }}

  # Integration tests after builds complete
  integration-tests:
    needs: [service-tests, frontend-jobs]
    strategy:
      matrix:
        test-suite: [api-integration, end-to-end, performance, security]
      max-parallel: 4
    runs-on: self-hosted
    name: ${{ matrix.test-suite }} Tests
    steps:
      - uses: actions/checkout@v4
      - name: Run ${{ matrix.test-suite }}
        run: |
          echo "Running ${{ matrix.test-suite }} tests on runner: ${{ runner.name }}"
          # Integration test commands here

  # Deployment (sequential after all tests pass)
  deploy:
    needs: [docker-builds, integration-tests]
    if: github.ref == 'refs/heads/main'
    runs-on: self-hosted
    environment: production
    steps:
      - uses: actions/checkout@v4
      - name: Deploy to production
        run: |
          echo "Deploying to production from runner: ${{ runner.name }}"
          # Deployment commands here