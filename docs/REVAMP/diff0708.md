here’s T08 (Auth/RBAC) as git-applyable diffs + exact run/verify steps. This adds a JWT-validating Gateway (default port 8000) with group→role mapping, protects Azure Agents and Core APIs, and flips your frontend to call the gateway (default-deny, health is public).

✅ Unified diffs (save as t08_auth_rbac.patch, then run git apply t08_auth_rbac.patch)
diff --git a/.env.example b/.env.example
index abcd123..f0a1e2b 100644
--- a/.env.example
+++ b/.env.example
@@ -1,8 +1,9 @@
 # === PolicyCortex - Example Environment (copy to .env and fill) ===
 # Runtime mode
 NEXT_PUBLIC_DEMO_MODE=false
 USE_REAL_DATA=true
-NEXT_PUBLIC_REAL_API_BASE=http://localhost:8084
+# Frontend hits the Gateway (which enforces JWT/RBAC and proxies to services)
+NEXT_PUBLIC_REAL_API_BASE=http://localhost:8000
 
 # Azure (Entra ID)
 AZURE_TENANT_ID=your-tenant-id
@@ -13,6 +14,28 @@ AZURE_CLIENT_SECRET=your-client-secret
 DATABASE_URL=postgres://pcx:pcx@localhost:5432/pcx
 REDIS_URL=redis://localhost:6379
 
+# Auth (OIDC/JWT via Azure AD)
+JWT_ISSUER=https://login.microsoftonline.com/<tenant-id>/v2.0
+JWT_AUDIENCE=<your-app-client-id>
+JWT_JWKS_URL=https://login.microsoftonline.com/<tenant-id>/discovery/v2.0/keys
+# Map Azure AD group IDs to roles (comma-separated GUIDs)
+ADMIN_GROUP_IDS=<guid1>,<guid2>
+AUDITOR_GROUP_IDS=<guid3>
+OPERATOR_GROUP_IDS=<guid4>
+
+# Gateway → service targets
+GATEWAY_PORT=8000
+CORE_URL=http://localhost:8081
+AZURE_AGENTS_URL=http://localhost:8084
+
 # GitHub App (for Auto-Fix PRs)
 GITHUB_APP_ID=
 GITHUB_INSTALLATION_ID=
 GITHUB_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"
 
diff --git a/services/gateway/package.json b/services/gateway/package.json
new file mode 100644
index 0000000..31b2e9f
--- /dev/null
+++ b/services/gateway/package.json
@@ -0,0 +1,33 @@
+{
+  "name": "pcx-gateway",
+  "private": true,
+  "type": "module",
+  "version": "0.1.0",
+  "description": "PolicyCortex Gateway: JWT/RBAC, routing, and schema enforcement entrypoint",
+  "scripts": {
+    "dev": "tsx src/index.ts",
+    "start": "node --enable-source-maps dist/index.js",
+    "build": "tsc -p tsconfig.json"
+  },
+  "dependencies": {
+    "cors": "^2.8.5",
+    "express": "^4.19.2",
+    "http-proxy-middleware": "^3.0.3",
+    "jose": "^5.9.3"
+  },
+  "devDependencies": {
+    "tslib": "^2.6.3",
+    "tsx": "^4.16.2",
+    "typescript": "^5.5.4"
+  }
+}
diff --git a/services/gateway/tsconfig.json b/services/gateway/tsconfig.json
new file mode 100644
index 0000000..7f8a6f3
--- /dev/null
+++ b/services/gateway/tsconfig.json
@@ -0,0 +1,21 @@
+{
+  "compilerOptions": {
+    "target": "ES2022",
+    "module": "ES2022",
+    "moduleResolution": "Bundler",
+    "strict": true,
+    "esModuleInterop": true,
+    "forceConsistentCasingInFileNames": true,
+    "skipLibCheck": true,
+    "outDir": "dist"
+  },
+  "include": ["src/**/*.ts"]
+}
diff --git a/services/gateway/src/index.ts b/services/gateway/src/index.ts
new file mode 100644
index 0000000..badd00d
--- /dev/null
+++ b/services/gateway/src/index.ts
@@ -0,0 +1,236 @@
+import 'dotenv/config';
+import express from 'express';
+import cors from 'cors';
+import { createProxyMiddleware } from 'http-proxy-middleware';
+import { createRemoteJWKSet, jwtVerify, JWTPayload } from 'jose';
+
+// ---- Env
+const PORT = Number(process.env.GATEWAY_PORT || 8000);
+const CORE_URL = process.env.CORE_URL || 'http://localhost:8081';
+const AZURE_AGENTS_URL = process.env.AZURE_AGENTS_URL || 'http://localhost:8084';
+const ISSUER = process.env.JWT_ISSUER!;
+const AUDIENCE = process.env.JWT_AUDIENCE!;
+const JWKS_URL = process.env.JWT_JWKS_URL!;
+const ADMIN_GROUP_IDS = (process.env.ADMIN_GROUP_IDS || '').split(',').map(s => s.trim()).filter(Boolean);
+const AUDITOR_GROUP_IDS = (process.env.AUDITOR_GROUP_IDS || '').split(',').map(s => s.trim()).filter(Boolean);
+const OPERATOR_GROUP_IDS = (process.env.OPERATOR_GROUP_IDS || '').split(',').map(s => s.trim()).filter(Boolean);
+
+if (!ISSUER || !AUDIENCE || !JWKS_URL) {
+  console.warn('[gateway] WARNING: JWT_ISSUER, JWT_AUDIENCE, JWT_JWKS_URL are not fully set.');
+}
+
+// ---- App
+const app = express();
+app.use(cors());
+app.use(express.json({ limit: '1mb' }));
+
+// ---- Auth helpers
+const JWKS = createRemoteJWKSet(new URL(JWKS_URL));
+type Role = 'admin' | 'auditor' | 'operator' | 'unknown';
+
+function mapRoleFromPayload(p: JWTPayload): Role {
+  const groups: string[] = Array.isArray((p as any).groups) ? (p as any).groups : [];
+  const inAny = (ids: string[]) => groups.some(g => ids.includes(g));
+  if (inAny(ADMIN_GROUP_IDS)) return 'admin';
+  if (inAny(AUDITOR_GROUP_IDS)) return 'auditor';
+  if (inAny(OPERATOR_GROUP_IDS)) return 'operator';
+  return 'unknown';
+}
+
+async function verifyBearer(authHeader?: string): Promise<{ role: Role; payload: JWTPayload } | null> {
+  if (!authHeader || !authHeader.startsWith('Bearer ')) return null;
+  const token = authHeader.slice(7);
+  const { payload } = await jwtVerify(token, JWKS, { issuer: ISSUER, audience: AUDIENCE });
+  const role = mapRoleFromPayload(payload);
+  return { role, payload };
+}
+
+function requireRole(allowed: Role[]) {
+  return async (req: express.Request, res: express.Response, next: express.NextFunction) => {
+    try {
+      const v = await verifyBearer(req.get('authorization'));
+      if (!v) return res.status(401).json({ error: 'missing_or_invalid_token' });
+      if (!allowed.includes(v.role)) return res.status(403).json({ error: 'forbidden', role: v.role });
+      // attach user to request
+      (req as any).user = { role: v.role, sub: v.payload.sub, tid: (v.payload as any).tid, oid: (v.payload as any).oid };
+      return next();
+    } catch (e: any) {
+      return res.status(401).json({ error: 'token_verify_failed', detail: String(e?.message || e) });
+    }
+  };
+}
+
+// ---- Public health
+app.get('/health', (_req, res) => res.json({ ok: true, time: new Date().toISOString() }));
+
+// ---- RBAC policy (default deny)
+// Core (events/evidence): auditors & admins can read; operators/admins can write events
+app.use(
+  '/api/v1/events',
+  requireRole(['operator', 'admin']),
+  createProxyMiddleware({
+    target: CORE_URL,
+    changeOrigin: true,
+    xfwd: true
+  })
+);
+app.get(
+  '/api/v1/events/replay',
+  requireRole(['auditor', 'admin', 'operator']),
+  createProxyMiddleware({ target: CORE_URL, changeOrigin: true, xfwd: true })
+);
+app.get(
+  '/api/v1/verify/*',
+  requireRole(['auditor', 'admin', 'operator']),
+  createProxyMiddleware({ target: CORE_URL, changeOrigin: true, xfwd: true })
+);
+
+// Azure Agents (predictions + P&L): all roles can read
+app.get(
+  '/api/v1/predictions',
+  requireRole(['auditor', 'admin', 'operator']),
+  createProxyMiddleware({ target: AZURE_AGENTS_URL, changeOrigin: true, xfwd: true })
+);
+app.get(
+  '/api/v1/costs/pnl',
+  requireRole(['auditor', 'admin', 'operator']),
+  createProxyMiddleware({ target: AZURE_AGENTS_URL, changeOrigin: true, xfwd: true })
+);
+
+// ---- Fallback
+app.use((_req, res) => res.status(404).json({ error: 'not_found' }));
+
+app.listen(PORT, () => {
+  console.log(`[gateway] listening on http://0.0.0.0:${PORT}`);
+  console.log(`[gateway] → CORE_URL=${CORE_URL}  AZURE_AGENTS_URL=${AZURE_AGENTS_URL}`);
+});
diff --git a/services/agents/azure/src/index.ts b/services/agents/azure/src/index.ts
index cafe004..c1f09aa 100644
--- a/services/agents/azure/src/index.ts
+++ b/services/agents/azure/src/index.ts
@@ -1,17 +1,33 @@
 import 'dotenv/config';
 import express from 'express';
 import cors from 'cors';
 import { z } from 'zod';
 import { DefaultAzureCredential } from '@azure/identity';
 import { CostManagementClient, QueryDefinition, TimeframeType } from '@azure/arm-costmanagement';
+import { createRemoteJWKSet, jwtVerify, JWTPayload } from 'jose';
 
 // ---- Env / Config --------------------------------------------------------------------
 const PORT = Number(process.env.PORT || 8084);
@@ -7,6 +23,21 @@ const SUBSCRIPTION_ID = process.env.AZURE_SUBSCRIPTION_ID || '';
 const TENANT_ID = process.env.AZURE_TENANT_ID || '';
 const CLIENT_ID = process.env.AZURE_CLIENT_ID || '';
 const CLIENT_SECRET = process.env.AZURE_CLIENT_SECRET || '';
+const ISSUER = process.env.JWT_ISSUER!;
+const AUDIENCE = process.env.JWT_AUDIENCE!;
+const JWKS_URL = process.env.JWT_JWKS_URL!;
+const ADMIN_GROUP_IDS = (process.env.ADMIN_GROUP_IDS || '').split(',').map(s => s.trim()).filter(Boolean);
+const AUDITOR_GROUP_IDS = (process.env.AUDITOR_GROUP_IDS || '').split(',').map(s => s.trim()).filter(Boolean);
+const OPERATOR_GROUP_IDS = (process.env.OPERATOR_GROUP_IDS || '').split(',').map(s => s.trim()).filter(Boolean);
+const JWKS = createRemoteJWKSet(new URL(JWKS_URL));
+type Role = 'admin' | 'auditor' | 'operator' | 'unknown';
+function roleFromPayload(p: JWTPayload): Role {
+  const groups: string[] = Array.isArray((p as any).groups) ? (p as any).groups : [];
+  const inAny = (ids: string[]) => groups.some(g => ids.includes(g));
+  if (inAny(ADMIN_GROUP_IDS)) return 'admin';
+  if (inAny(AUDITOR_GROUP_IDS)) return 'auditor';
+  if (inAny(OPERATOR_GROUP_IDS)) return 'operator';
+  return 'unknown';
+}
 const ML_PREDICT_URL = process.env.ML_PREDICT_URL || 'http://localhost:8001/predict';
 const ML_EXPLAIN_URL = process.env.ML_EXPLAIN_URL || process.env.ML_PREDICT_URL || 'http://localhost:8001/predict';
 const DEFAULT_FIX_REPO = process.env.DEFAULT_FIX_REPO || 'org/infrastructure';
@@ -15,11 +46,31 @@ const SAVINGS_RATE = Number(process.env.SAVINGS_RATE || '0.10'); // 10% default (spec: 8–12%)
 // ---- App -----------------------------------------------------------------------------
 const app = express();
 app.use(cors());
 app.use(express.json({ limit: '1mb' }));
 
+async function requireAuth(req: express.Request, res: express.Response, next: express.NextFunction) {
+  try {
+    const h = req.get('authorization');
+    if (!h || !h.startsWith('Bearer ')) return res.status(401).json({ error: 'missing_or_invalid_token' });
+    const token = h.slice(7);
+    const { payload } = await jwtVerify(token, JWKS, { issuer: ISSUER, audience: AUDIENCE });
+    const role = roleFromPayload(payload);
+    if (role === 'unknown') return res.status(403).json({ error: 'forbidden' });
+    (req as any).user = { role, sub: payload.sub, tid: (payload as any).tid, oid: (payload as any).oid };
+    return next();
+  } catch (e: any) {
+    return res.status(401).json({ error: 'token_verify_failed', detail: String(e?.message || e) });
+  }
+}
+
 app.get('/health', (_req, res) => {
   const hasAzure = !!(SUBSCRIPTION_ID && TENANT_ID && CLIENT_ID && CLIENT_SECRET);
   return res.json({
     ok: true,
     azureConfigured: hasAzure,
     mlPredictUrl: ML_PREDICT_URL,
     time: new Date().toISOString(),
   });
 });
 
+// Protect all API routes (health stays public)
+app.use('/api/', requireAuth);
+
 // ---- /api/v1/predictions -------------------------------------------------------------
 // Accepts ?scope=subscription|rg|tags:...&horizon=<days>
 const PredictQuery = z.object({
diff --git a/services/core/Cargo.toml b/services/core/Cargo.toml
index c0ffee1..7c0ffee 100644
--- a/services/core/Cargo.toml
+++ b/services/core/Cargo.toml
@@ -10,6 +10,11 @@ serde_json = "1"
 sqlx = { version = "0.7", features = ["runtime-tokio", "postgres", "macros", "chrono", "json"] }
 sha2 = "0.10"
 anyhow = "1"
 thiserror = "1"
 tower-http = { version = "0.5", features = ["cors", "trace"] }
 dotenvy = "0.15"
 chrono = { version = "0.4", features = ["clock"] }
 hex = "0.4"
+jsonwebtoken = "9"
+reqwest = { version = "0.12", features = ["json", "rustls-tls"] }
+once_cell = "1"
+base64 = "0.22"
+headers = "0.4"
diff --git a/services/core/src/main.rs b/services/core/src/main.rs
index bada55e..deadc0d 100644
--- a/services/core/src/main.rs
+++ b/services/core/src/main.rs
@@ -1,27 +1,36 @@
-use axum::{extract::{Path, State}, routing::{get, post}, Json, Router};
+use axum::{extract::{Path, State}, http::Request, middleware::from_fn_with_state, routing::{get, post}, Json, Router};
 use serde::{Deserialize, Serialize};
 use serde_json::Value as JsonValue;
 use sqlx::{postgres::PgPoolOptions, PgPool};
 use std::{env, net::SocketAddr};
 use tower_http::cors::{Any, CorsLayer};
 use chrono::{Utc, NaiveDate};
+use headers::HeaderMapExt;
 
 mod merkle;
 use merkle::{hex_to_hash, merkle_root_and_proof, Hash32};
 
+mod oidc;
+use oidc::{AuthState, auth_middleware};
+
 #[derive(Clone)]
 struct AppState {
     pool: PgPool,
+    auth: AuthState,
 }
 
 #[tokio::main]
 async fn main() -> anyhow::Result<()> {
     dotenvy::dotenv().ok();
     let db_url = env::var("DATABASE_URL")
         .expect("DATABASE_URL is required (e.g., postgres://pcx:pcx@localhost:5432/pcx)");
     let port: u16 = env::var("CORE_PORT").ok().and_then(|s| s.parse().ok()).unwrap_or(8081);
+    let issuer = env::var("JWT_ISSUER").expect("JWT_ISSUER required");
+    let audience = env::var("JWT_AUDIENCE").expect("JWT_AUDIENCE required");
+    let jwks_url = env::var("JWT_JWKS_URL").expect("JWT_JWKS_URL required");
+    let admin = env::var("ADMIN_GROUP_IDS").unwrap_or_default();
+    let auditor = env::var("AUDITOR_GROUP_IDS").unwrap_or_default();
+    let operator = env::var("OPERATOR_GROUP_IDS").unwrap_or_default();
 
     let pool = PgPoolOptions::new()
         .max_connections(10)
         .connect(&db_url)
         .await?;
 
-    let state = AppState { pool };
+    let state = AppState { pool, auth: AuthState::new(&issuer, &audience, &jwks_url, &admin, &auditor, &operator) };
     let app = Router::new()
         .route("/health", get(health))
         // Events (T04)
-        .route("/api/v1/events", post(append_event).get(list_events))
-        .route("/api/v1/events/replay", get(replay_events))
+        .route("/api/v1/events", post(append_event).get(list_events))
+        .route("/api/v1/events/replay", get(replay_events))
         // Evidence verify (T05)
         .route("/api/v1/verify/:hash", get(verify_hash))
-        .with_state(state)
+        // Protect all /api routes (health is public)
+        .layer(from_fn_with_state(state.clone(), auth_middleware))
+        .with_state(state)
         .layer(
             CorsLayer::new()
                 .allow_methods(Any)
@@ -47,6 +56,7 @@ async fn health(State(state): State<AppState>) -> Json<serde_json::Value> {
         "time": Utc::now().to_rfc3339(),
     }))
 }
@@ -134,7 +144,7 @@ async fn verify_hash(
     // Ensure hex hash format
     if hash_hex.len() != 64 || !hash_hex.chars().all(|c| c.is_ascii_hexdigit()) {
         return Err((axum::http::StatusCode::BAD_REQUEST, "invalid hash".into()));
     }
 
     // Find evidence row
diff --git a/services/core/src/oidc.rs b/services/core/src/oidc.rs
new file mode 100644
index 0000000..c001d00
--- /dev/null
+++ b/services/core/src/oidc.rs
@@ -0,0 +1,198 @@
+use axum::{extract::State, http::{Request, StatusCode}, response::Response};
+use base64::{engine::general_purpose::STANDARD, Engine as _};
+use jsonwebtoken::{decode, decode_header, Algorithm, DecodingKey, Validation};
+use once_cell::sync::OnceCell;
+use reqwest::Client;
+use serde::Deserialize;
+use std::{collections::HashMap, sync::Arc};
+
+#[derive(Clone)]
+pub struct AuthState {
+    pub issuer: String,
+    pub audience: String,
+    pub jwks_url: String,
+    pub admin_groups: Vec<String>,
+    pub auditor_groups: Vec<String>,
+    pub operator_groups: Vec<String>,
+    http: Client,
+}
+
+impl AuthState {
+    pub fn new(issuer: &str, audience: &str, jwks_url: &str, admin: &str, auditor: &str, operator: &str) -> Self {
+        let parse = |s: &str| s.split(',').map(|x| x.trim().to_string()).filter(|x| !x.is_empty()).collect();
+        Self {
+            issuer: issuer.to_string(),
+            audience: audience.to_string(),
+            jwks_url: jwks_url.to_string(),
+            admin_groups: parse(admin),
+            auditor_groups: parse(auditor),
+            operator_groups: parse(operator),
+            http: Client::builder().build().unwrap(),
+        }
+    }
+}
+
+#[derive(Deserialize)]
+struct Jwk {
+    kid: String,
+    n: String,
+    e: String,
+    kty: String,
+}
+#[derive(Deserialize)]
+struct Jwks { keys: Vec<Jwk> }
+
+static JWKS_CACHE: OnceCell<Arc<Jwks>> = OnceCell::new();
+
+async fn get_jwks(state: &AuthState) -> anyhow::Result<Arc<Jwks>> {
+    if let Some(c) = JWKS_CACHE.get() { return Ok(c.clone()); }
+    let jwks: Jwks = state.http.get(&state.jwks_url).send().await?.json().await?;
+    let arc = Arc::new(jwks);
+    let _ = JWKS_CACHE.set(arc.clone());
+    Ok(arc)
+}
+
+#[derive(Deserialize)]
+struct Claims {
+    iss: String,
+    aud: Option<String>,
+    #[serde(default)]
+    groups: Option<Vec<String>>,
+}
+
+fn role_from_groups(groups: &[String], state: &AuthState) -> &'static str {
+    let any_in = |want: &Vec<String>| groups.iter().any(|g| want.contains(g));
+    if any_in(&state.admin_groups) { "admin" }
+    else if any_in(&state.auditor_groups) { "auditor" }
+    else if any_in(&state.operator_groups) { "operator" }
+    else { "unknown" }
+}
+
+pub async fn auth_middleware<B>(State(state): State<super::AppState>, mut req: Request<B>, next: axum::middleware::Next<B>) -> Result<Response, (StatusCode, String)> {
+    // Allow health without auth
+    let path = req.uri().path().to_string();
+    if path == "/health" { return Ok(next.run(req).await); }
+
+    // Require Authorization: Bearer
+    let Some(auth) = req.headers().get(axum::http::header::AUTHORIZATION) else {
+        return Err((StatusCode::UNAUTHORIZED, "missing Authorization".into()));
+    };
+    let Ok(auth_str) = auth.to_str() else { return Err((StatusCode::UNAUTHORIZED, "invalid Authorization".into())); };
+    if !auth_str.starts_with("Bearer ") { return Err((StatusCode::UNAUTHORIZED, "invalid Authorization".into())); }
+    let token = &auth_str[7..];
+
+    // Decode header to get kid
+    let header = decode_header(token).map_err(|e| (StatusCode::UNAUTHORIZED, format!("decode header: {e}")))?;
+    let kid = header.kid.ok_or((StatusCode::UNAUTHORIZED, "missing kid".to_string()))?;
+
+    // Fetch JWKS and find key
+    let jwks = get_jwks(&state.auth).await.map_err(|e| (StatusCode::UNAUTHORIZED, format!("jwks fetch: {e}")))?;
+    let jwk = jwks.keys.iter().find(|k| k.kid == kid).ok_or((StatusCode::UNAUTHORIZED, "kid not found".to_string()))?;
+
+    // Build decoding key from RSA components
+    let n_bytes = STANDARD.decode(&jwk.n).map_err(|e| (StatusCode::UNAUTHORIZED, format!("n decode: {e}")))?;
+    let e_bytes = STANDARD.decode(&jwk.e).map_err(|e| (StatusCode::UNAUTHORIZED, format!("e decode: {e}")))?;
+    let n_b64 = base64::engine::general_purpose::STANDARD.encode(n_bytes);
+    let e_b64 = base64::engine::general_purpose::STANDARD.encode(e_bytes);
+    let key = DecodingKey::from_rsa_components(&n_b64, &e_b64).map_err(|e| (StatusCode::UNAUTHORIZED, format!("key build: {e}")))?;
+
+    let mut v = Validation::new(Algorithm::RS256);
+    v.set_issuer(&[state.auth.issuer.clone()]);
+    v.set_audience(&[state.auth.audience.clone()]);
+
+    let data = decode::<Claims>(token, &key, &v).map_err(|e| (StatusCode::UNAUTHORIZED, format!("verify: {e}")))?;
+    if data.claims.iss != state.auth.issuer { return Err((StatusCode::UNAUTHORIZED, "bad iss".into())); }
+
+    // Role from groups
+    let groups = data.claims.groups.unwrap_or_default();
+    let role = role_from_groups(&groups, &state.auth);
+    if role == "unknown" {
+        return Err((StatusCode::FORBIDDEN, "forbidden".into()));
+    }
+
+    // Attach role to request extensions
+    req.extensions_mut().insert(role.to_string());
+    Ok(next.run(req).await)
+}

▶️ Run
# 1) Set env (edit .env or export) with your Azure AD values:
#    JWT_ISSUER, JWT_AUDIENCE, JWT_JWKS_URL, and group IDs for ADMIN/AUDITOR/OPERATOR
#    Also set CORE_URL and AZURE_AGENTS_URL if you changed ports.

# 2) Start Core (Rust)
cd services/core
cargo run --release
# → pcx-core on :8081

# 3) Start Azure Agents (Node)
cd ../../services/agents/azure
pnpm install
pnpm dev
# → pcx-agents-azure on :8084

# 4) Start Gateway (Node)
cd ../../services/gateway
pnpm install
pnpm dev
# → pcx-gateway on :8000

# 5) Frontend (will call Gateway via NEXT_PUBLIC_REAL_API_BASE)
cd ../../
pnpm -w dev

✅ Verify (T08 acceptance)

Health (public)

curl -s http://localhost:8000/health | jq


Unauthorized is blocked (no token)

curl -is http://localhost:8000/api/v1/predictions | head -n 1   # => HTTP/1.1 401
curl -is http://localhost:8000/api/v1/events/replay | head -n 1 # => HTTP/1.1 401


Authorized (Bearer token with group in OPERATOR/AUDITOR/ADMIN)

export TOKEN="eyJ..."  # Azure AD JWT for your app (aud matches JWT_AUDIENCE)
curl -s -H "Authorization: Bearer $TOKEN" "http://localhost:8000/api/v1/predictions" | jq
curl -s -H "Authorization: Bearer $TOKEN" "http://localhost:8000/api/v1/costs/pnl" | jq
curl -s -H "Authorization: Bearer $TOKEN" "http://localhost:8000/api/v1/events/replay" | jq


RBAC enforced (write requires operator/admin)

# With OPERATOR/ADMIN token:
curl -s -o /dev/null -w "%{http_code}\n" -H "Authorization: Bearer $TOKEN" \
  -H "content-type: application/json" \
  -d '{"payload":{"type":"PnlForecasted","items":[],"timestamp":"2025-09-05T00:00:00Z"}}' \
  http://localhost:8000/api/v1/events
# => 200


Forbidden for unknown roles

# Use a token that lacks mapped groups
curl -s -o /dev/null -w "%{http_code}\n" -H "Authorization: Bearer $TOKEN_WEAK" \
  http://localhost:8000/api/v1/costs/pnl
# => 403

Notes / Fit to Spec

Default-deny: all /api/* paths require JWT; only /health is public.

Group→role mapping: uses ADMIN_GROUP_IDS, AUDITOR_GROUP_IDS, OPERATOR_GROUP_IDS.

Gateway is now your single entrypoint (frontend already points to it via NEXT_PUBLIC_REAL_API_BASE).