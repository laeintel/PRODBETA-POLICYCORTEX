name: Application Deployment

permissions:
  contents: read
  actions: read
  security-events: write
  issues: write
  pull-requests: write

# Temporarily disabled automatic triggers due to billing issues
# Re-enable when billing is resolved by uncommenting the triggers below

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'docker-compose*.yml'
      - '.github/workflows/application-deploy.yml'
      - 'Dockerfile*'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'docker-compose*.yml'
      - '.github/workflows/application-deploy.yml'
      - 'Dockerfile*'
  workflow_dispatch:  # Manual trigger
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip tests to save minutes'
        required: false
        default: true
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  # Combine all tests into one job to save minutes
  test-all:
    name: Run Tests (Optional)
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Test Frontend (Quick)
        working-directory: ./frontend
        run: |
          npm ci
          npm run build  # Just build, skip long tests
      
      - name: Test Backend (Quick)
        run: |
          # Just check if Python files are valid
          python -m py_compile backend/services/api_gateway/main.py
          echo "Basic syntax check passed"

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    continue-on-error: true  # Don't fail entire pipeline on security scan failures
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

      - name: Run Bandit security linter
        run: |
          pip install bandit
          bandit -r backend/ -f json -o bandit-results.json
        continue-on-error: true

      - name: Upload Bandit results
        uses: actions/upload-artifact@v4
        with:
          name: bandit-results
          path: bandit-results.json
        continue-on-error: true

  build-backend:
    name: Build Backend Services
    runs-on: ubuntu-latest
    needs: [test-all]
    if: always()  # Run even if tests fail
    strategy:
      matrix:
        service: [api_gateway, azure_integration, ai_engine, data_processing, conversation, notification]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get ACR Details
        id: get_acr
        run: |
          ACR_NAME=$(az acr list --query "[?contains(name, 'crpolicortex001dev')].name" -o tsv)
          ACR_LOGIN_SERVER=$(az acr show --name $ACR_NAME --query "loginServer" -o tsv)
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:buildx-stable-1

      - name: Login to Azure Container Registry
        run: |
          az acr login --name ${{ steps.get_acr.outputs.acr_name }}

      - name: Convert service name
        id: service_name
        run: |
          SERVICE_NAME="${{ matrix.service }}"
          SERVICE_NAME_HYPHEN=$(echo "$SERVICE_NAME" | sed 's/_/-/g')
          echo "hyphen_name=$SERVICE_NAME_HYPHEN" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.get_acr.outputs.acr_login_server }}/policortex001-${{ steps.service_name.outputs.hyphen_name }}
          tags: |
            type=raw,value=latest
            type=raw,value=v1-{{date 'DDMMYYYYHHMM'}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: backend
          file: backend/services/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: [test-all]
    if: always()  # Run even if tests fail
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get ACR Details
        id: get_acr
        run: |
          ACR_NAME=$(az acr list --query "[?contains(name, 'crpolicortex001dev')].name" -o tsv)
          ACR_LOGIN_SERVER=$(az acr show --name $ACR_NAME --query "loginServer" -o tsv)
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd frontend
          npm install

      - name: Build application
        run: |
          cd frontend
          npm run build

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:buildx-stable-1

      - name: Login to Azure Container Registry
        run: |
          az acr login --name ${{ steps.get_acr.outputs.acr_name }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.get_acr.outputs.acr_login_server }}/policortex001-frontend
          tags: |
            type=raw,value=latest
            type=raw,value=v1-{{date 'DDMMYYYYHHMM'}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: frontend
          file: frontend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    environment: dev
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Azure Resources
        id: get_resources
        run: |
          # Get resource group for dev environment - specifically the app resource group
          RESOURCE_GROUP=$(az group list --query "[?contains(name, 'rg-policortex001-app-dev')].name" -o tsv | head -n 1)
          
          # Fallback to any dev resource group if not found
          if [ -z "$RESOURCE_GROUP" ]; then
            RESOURCE_GROUP=$(az group list --query "[?contains(name, 'rg-policortex') && contains(name, 'dev') && contains(name, 'app')].name" -o tsv | head -n 1)
          fi
          
          echo "Using resource group: $RESOURCE_GROUP"
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          
          # Get ACR details
          ACR_NAME=$(az acr list --query "[?contains(name, 'crpolicortex001dev')].name" -o tsv)
          ACR_LOGIN_SERVER=$(az acr show --name $ACR_NAME --query "loginServer" -o tsv)
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          
          # Get Container App Environment - add error checking
          if [ -n "$RESOURCE_GROUP" ]; then
            CONTAINER_ENV_NAME=$(az containerapp env list --resource-group "$RESOURCE_GROUP" --query "[0].name" -o tsv)
            echo "container_env_name=$CONTAINER_ENV_NAME" >> $GITHUB_OUTPUT
          else
            echo "ERROR: Could not find resource group"
            exit 1
          fi

      - name: Deploy to Container Apps
        run: |
          # Remove the manually added service-name secret that's causing conflicts
          # This is needed because we changed service-name from a secret to a plain env var
          for service in api-gateway azure-integration ai-engine data-processing conversation notification frontend; do
            echo "Cleaning up service-name secret from ca-${service}-dev..."
            az containerapp secret delete \
              --name ca-${service}-dev \
              --resource-group ${{ steps.get_resources.outputs.resource_group }} \
              --secret-names service-name \
              --yes 2>/dev/null || true
          done
          
          # Deploy each microservice using latest tags for consistency with Terraform
          az containerapp update \
            --name ca-api-gateway-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image ${{ steps.get_resources.outputs.acr_login_server }}/policortex001-api-gateway:latest
          
          az containerapp update \
            --name ca-azure-integration-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image ${{ steps.get_resources.outputs.acr_login_server }}/policortex001-azure-integration:latest
          
          az containerapp update \
            --name ca-ai-engine-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image ${{ steps.get_resources.outputs.acr_login_server }}/policortex001-ai-engine:latest
          
          az containerapp update \
            --name ca-data-processing-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image ${{ steps.get_resources.outputs.acr_login_server }}/policortex001-data-processing:latest
          
          az containerapp update \
            --name ca-conversation-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image ${{ steps.get_resources.outputs.acr_login_server }}/policortex001-conversation:latest
          
          az containerapp update \
            --name ca-notification-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image ${{ steps.get_resources.outputs.acr_login_server }}/policortex001-notification:latest
          
          az containerapp update \
            --name ca-frontend-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image ${{ steps.get_resources.outputs.acr_login_server }}/policortex001-frontend:latest

      - name: Wait for deployments
        run: |
          echo "Waiting for Container Apps to be ready..."
          sleep 60
          
          # Check deployment status
          az containerapp show --name ca-api-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.provisioningState" -o tsv
          az containerapp show --name ca-frontend-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.provisioningState" -o tsv

      - name: Run health checks
        continue-on-error: true
        run: |
          # Get Container App URLs
          API_GATEWAY_URL=$(az containerapp show --name ca-api-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.configuration.ingress.fqdn" -o tsv)
          FRONTEND_URL=$(az containerapp show --name ca-frontend-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.configuration.ingress.fqdn" -o tsv)
          
          echo "API Gateway URL: https://${API_GATEWAY_URL}"
          echo "Frontend URL: https://${FRONTEND_URL}"
          
          # Health check function with retries
          check_health() {
            local url=$1
            local max_attempts=10
            local wait_time=30
            
            for i in $(seq 1 $max_attempts); do
              echo "Attempt $i/$max_attempts for $url"
              if curl -f -m 30 "$url" > /dev/null 2>&1; then
                echo "✓ Health check passed for $url"
                return 0
              fi
              
              if [ $i -lt $max_attempts ]; then
                echo "Health check failed, waiting ${wait_time}s before retry..."
                sleep $wait_time
              fi
            done
            
            echo "✗ Health check failed after $max_attempts attempts for $url"
            return 1
          }
          
          # Run health checks with retries
          HEALTH_CHECK_FAILED=false
          
          if ! check_health "https://${API_GATEWAY_URL}/health"; then
            echo "⚠️  WARNING: API Gateway health check failed but deployment continues"
            HEALTH_CHECK_FAILED=true
          fi
          
          if ! check_health "https://${FRONTEND_URL}/"; then
            echo "⚠️  WARNING: Frontend health check failed but deployment continues"
            HEALTH_CHECK_FAILED=true
          fi
          
          if [ "$HEALTH_CHECK_FAILED" = "true" ]; then
            echo ""
            echo "⚠️  Health checks failed but deployment was successful."
            echo "📋 Next steps:"
            echo "   1. Check Container Apps logs: az containerapp logs show -n ca-api-gateway-dev -g ${{ steps.get_resources.outputs.resource_group }}"
            echo "   2. Check application startup issues"
            echo "   3. Verify environment variables are set correctly"
            echo ""
          fi

  diagnose-dev:
    name: Diagnose Development Issues
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    if: always() && github.ref == 'refs/heads/main'
    continue-on-error: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get resource group
        id: get_resources
        run: |
          # Get resource group for dev environment - use specific name pattern
          RESOURCE_GROUP=$(az group list --query "[?contains(name, 'rg-policortex001-app-dev')].name" -o tsv | head -n 1)
          
          # Fallback to any rg-policortex with dev
          if [ -z "$RESOURCE_GROUP" ]; then
            RESOURCE_GROUP=$(az group list --query "[?contains(name, 'rg-policortex') && contains(name, 'dev')].name" -o tsv | head -n 1)
          fi
          
          echo "Using resource group: $RESOURCE_GROUP"
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT

      - name: Check Container Apps Status
        run: |
          echo "=== Container Apps Status ==="
          echo ""
          
          # Check API Gateway
          echo "🔍 API Gateway Status:"
          az containerapp show --name ca-api-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --query "{status: properties.provisioningState, replicas: properties.template.scale.maxReplicas, image: properties.template.containers[0].image}" -o json
          
          echo ""
          echo "📄 API Gateway Recent Logs:"
          az containerapp logs show --name ca-api-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --tail 50 || echo "Could not fetch logs"
          
          echo ""
          echo "=== Checking for common issues ==="
          echo ""
          
          # Check if environment variables are set
          echo "🔑 Environment Variables Status:"
          az containerapp show --name ca-api-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --query "properties.template.containers[0].env[?name=='DATABASE_URL' || name=='AZURE_KEY_VAULT_URL' || name=='AZURE_CLIENT_ID'].{name:name, hasValue:value}" -o table
          
          echo ""
          echo "🌐 Ingress Configuration:"
          az containerapp ingress show --name ca-api-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} -o json

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    if: github.event_name == 'workflow_dispatch' && contains(fromJson('["staging", "prod"]'), github.event.inputs.environment)
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to Container Apps
        run: |
          # Deploy each microservice
          az containerapp update \
            --name ca-api-gateway-staging \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} \
            --image ${{ env.REGISTRY }}/policortex001-api-gateway:${{ github.sha }}
          
          az containerapp update \
            --name ca-azure-integration-staging \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} \
            --image ${{ env.REGISTRY }}/policortex001-azure-integration:${{ github.sha }}
          
          az containerapp update \
            --name ca-ai-engine-staging \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} \
            --image ${{ env.REGISTRY }}/policortex001-ai-engine:${{ github.sha }}
          
          az containerapp update \
            --name ca-data-processing-staging \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} \
            --image ${{ env.REGISTRY }}/policortex001-data-processing:${{ github.sha }}
          
          az containerapp update \
            --name ca-conversation-staging \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} \
            --image ${{ env.REGISTRY }}/policortex001-conversation:${{ github.sha }}
          
          az containerapp update \
            --name ca-notification-staging \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} \
            --image ${{ env.REGISTRY }}/policortex001-notification:${{ github.sha }}
          
          az containerapp update \
            --name ca-frontend-staging \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} \
            --image ${{ env.REGISTRY }}/policortex001-frontend:${{ github.sha }}

      - name: Run health checks
        run: |
          # Wait for deployments
          sleep 60
          
          # Get Container App URLs
          API_GATEWAY_URL=$(az containerapp show --name ca-api-gateway-staging --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} --query "properties.configuration.ingress.fqdn" -o tsv)
          FRONTEND_URL=$(az containerapp show --name ca-frontend-staging --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_STAGING }} --query "properties.configuration.ingress.fqdn" -o tsv)
          
          # Health check endpoints
          curl -f https://${API_GATEWAY_URL}/health || exit 1
          curl -f https://${FRONTEND_URL}/ || exit 1

  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'
    environment: prod
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to Container Apps
        run: |
          # Deploy each microservice
          az containerapp update \
            --name ca-api-gateway-prod \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} \
            --image ${{ env.REGISTRY }}/policortex001-api-gateway:${{ github.sha }}
          
          az containerapp update \
            --name ca-azure-integration-prod \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} \
            --image ${{ env.REGISTRY }}/policortex001-azure-integration:${{ github.sha }}
          
          az containerapp update \
            --name ca-ai-engine-prod \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} \
            --image ${{ env.REGISTRY }}/policortex001-ai-engine:${{ github.sha }}
          
          az containerapp update \
            --name ca-data-processing-prod \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} \
            --image ${{ env.REGISTRY }}/policortex001-data-processing:${{ github.sha }}
          
          az containerapp update \
            --name ca-conversation-prod \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} \
            --image ${{ env.REGISTRY }}/policortex001-conversation:${{ github.sha }}
          
          az containerapp update \
            --name ca-notification-prod \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} \
            --image ${{ env.REGISTRY }}/policortex001-notification:${{ github.sha }}
          
          az containerapp update \
            --name ca-frontend-prod \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} \
            --image ${{ env.REGISTRY }}/policortex001-frontend:${{ github.sha }}

      - name: Run health checks
        run: |
          # Wait for deployments
          sleep 60
          
          # Get Container App URLs
          API_GATEWAY_URL=$(az containerapp show --name ca-api-gateway-prod --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} --query "properties.configuration.ingress.fqdn" -o tsv)
          FRONTEND_URL=$(az containerapp show --name ca-frontend-prod --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} --query "properties.configuration.ingress.fqdn" -o tsv)
          
          # Health check endpoints
          curl -f https://${API_GATEWAY_URL}/health || exit 1
          curl -f https://${FRONTEND_URL}/ || exit 1

      - name: Run smoke tests
        run: |
          # Run comprehensive smoke tests for production
          API_GATEWAY_URL=$(az containerapp show --name ca-api-gateway-prod --resource-group ${{ secrets.AZURE_RESOURCE_GROUP_PROD }} --query "properties.configuration.ingress.fqdn" -o tsv)
          
          # Test key endpoints
          curl -f https://${API_GATEWAY_URL}/api/v1/health || exit 1
          curl -f https://${API_GATEWAY_URL}/api/v1/policies || exit 1
          curl -f https://${API_GATEWAY_URL}/api/v1/conversations || exit 1

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Determine resource group
        id: get_rg
        run: |
          RESOURCE_GROUP="${{ secrets.AZURE_RESOURCE_GROUP_DEV }}"
          
          if [ "${{ github.event.inputs.environment }}" == "staging" ]; then
            RESOURCE_GROUP="${{ secrets.AZURE_RESOURCE_GROUP_STAGING }}"
          elif [ "${{ github.event.inputs.environment }}" == "prod" ]; then
            RESOURCE_GROUP="${{ secrets.AZURE_RESOURCE_GROUP_PROD }}"
          fi
          
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT

      - name: Rollback Container Apps
        run: |
          ENV="${{ github.event.inputs.environment || 'dev' }}"
          RESOURCE_GROUP="${{ steps.get_rg.outputs.resource_group }}"
          
          echo "Rolling back Container Apps in $RESOURCE_GROUP for environment $ENV"
          
          # Get previous revision for each Container App and rollback
          az containerapp revision list --name ca-api-gateway-$ENV --resource-group $RESOURCE_GROUP --query "[1].name" -o tsv | xargs -I {} az containerapp update --name ca-api-gateway-$ENV --resource-group $RESOURCE_GROUP --revision {}
          
          az containerapp revision list --name ca-azure-integration-$ENV --resource-group $RESOURCE_GROUP --query "[1].name" -o tsv | xargs -I {} az containerapp update --name ca-azure-integration-$ENV --resource-group $RESOURCE_GROUP --revision {}
          
          az containerapp revision list --name ca-ai-engine-$ENV --resource-group $RESOURCE_GROUP --query "[1].name" -o tsv | xargs -I {} az containerapp update --name ca-ai-engine-$ENV --resource-group $RESOURCE_GROUP --revision {}
          
          az containerapp revision list --name ca-data-processing-$ENV --resource-group $RESOURCE_GROUP --query "[1].name" -o tsv | xargs -I {} az containerapp update --name ca-data-processing-$ENV --resource-group $RESOURCE_GROUP --revision {}
          
          az containerapp revision list --name ca-conversation-$ENV --resource-group $RESOURCE_GROUP --query "[1].name" -o tsv | xargs -I {} az containerapp update --name ca-conversation-$ENV --resource-group $RESOURCE_GROUP --revision {}
          
          az containerapp revision list --name ca-notification-$ENV --resource-group $RESOURCE_GROUP --query "[1].name" -o tsv | xargs -I {} az containerapp update --name ca-notification-$ENV --resource-group $RESOURCE_GROUP --revision {}
          
          az containerapp revision list --name ca-frontend-$ENV --resource-group $RESOURCE_GROUP --query "[1].name" -o tsv | xargs -I {} az containerapp update --name ca-frontend-$ENV --resource-group $RESOURCE_GROUP --revision {}
          
          echo "Rollback completed for all Container Apps"