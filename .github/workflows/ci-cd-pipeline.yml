name: PolicyCortex CI/CD Pipeline

permissions:
  contents: write  # Changed from read to write for auto-formatting commits
  actions: read
  security-events: write
  checks: write
  pull-requests: write

on:
  push:
    branches: [main, develop, staging]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.gitignore'
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

env:
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  CONTAINER_REGISTRY: ${{ secrets.CONTAINER_REGISTRY }}
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: self-hosted
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
      infrastructure: ${{ steps.changes.outputs.infrastructure }}
      tests: ${{ steps.changes.outputs.tests }}
      config: ${{ steps.changes.outputs.config }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'requirements*.txt'
            frontend:
              - 'frontend/**'
              - 'package*.json'
            infrastructure:
              - 'infrastructure/**'
              - 'scripts/**'
            tests:
              - 'testing/**'
            config:
              - 'scripts/config-manager.py'
              - '.github/workflows/**'

  lint-and-format:
    name: Lint and Format
    runs-on: self-hosted
    needs: detect-changes
    if: needs.detect-changes.outputs.backend == 'true' || needs.detect-changes.outputs.frontend == 'true' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch' || needs.detect-changes.outputs.config == 'true' || github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        if: needs.detect-changes.outputs.backend == 'true'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python dependencies
        if: needs.detect-changes.outputs.backend == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install black flake8 isort mypy bandit safety
          pip install -r backend/requirements.txt
        shell: powershell

      - name: Run Python formatting (auto-fix)
        if: needs.detect-changes.outputs.backend == 'true'
        run: |
          # Auto-format with Black
          black --line-length 100 backend/
          
          # Auto-sort imports
          isort --profile black --line-length 100 backend/
        shell: powershell
        
      - name: Commit formatting changes
        if: needs.detect-changes.outputs.backend == 'true'
        run: |
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          
          # Configure git with token authentication
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Set up authentication
          $remoteUrl = "https://x-access-token:$env:GITHUB_TOKEN@github.com/$env:GITHUB_REPOSITORY.git"
          git remote set-url origin $remoteUrl
          
          # Check if there are changes to commit
          $gitStatus = git status --porcelain
          if ($gitStatus) {
            git add -A
            git commit -m "style: Auto-format code with Black and isort [skip ci]"
            git push origin HEAD:${{ github.ref_name }}
          } else {
            Write-Host "No formatting changes to commit"
          }
        shell: powershell
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
      
      - name: Run Python linting
        if: needs.detect-changes.outputs.backend == 'true'
        run: |
          # Flake8 linting
          flake8 backend/ --max-line-length=100 --extend-ignore=E203,W503
          
          # Type checking with MyPy
          try { mypy backend/ --ignore-missing-imports } catch { Write-Host "MyPy check completed with warnings" }
          
          # Security scanning with Bandit
          try { bandit -r backend/ -x backend/tests/ } catch { Write-Host "Bandit scan completed with warnings" }
          
          # Dependency vulnerability scanning
          try { safety check --json } catch { Write-Host "Safety check completed with warnings" }
        shell: powershell

      - name: Set up Node.js
        if: needs.detect-changes.outputs.frontend == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Node.js dependencies
        if: needs.detect-changes.outputs.frontend == 'true'
        run: |
          cd frontend
          npm ci

      - name: Run frontend linting
        if: needs.detect-changes.outputs.frontend == 'true'
        run: |
          cd frontend
          
          # ESLint
          npm run lint
          
          # Prettier formatting check
          npm run format:check
          
          # TypeScript type checking
          npm run type-check

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: [detect-changes, lint-and-format]
    if: needs.detect-changes.outputs.backend == 'true' || needs.detect-changes.outputs.frontend == 'true' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch' || needs.detect-changes.outputs.config == 'true' || github.ref == 'refs/heads/main'
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: policycortex_test
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        if: needs.detect-changes.outputs.backend == 'true'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache Python dependencies
        if: needs.detect-changes.outputs.backend == 'true'
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        if: needs.detect-changes.outputs.backend == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install -r testing/requirements.txt

      - name: Run backend unit tests
        if: needs.detect-changes.outputs.backend == 'true'
        env:
          ENVIRONMENT: testing
          TESTING: true
          AZURE_SQL_SERVER: localhost
          AZURE_SQL_DATABASE: policycortex_test
          AZURE_SQL_USERNAME: test
          AZURE_SQL_PASSWORD: test
          REDIS_URL: redis://localhost:6379/0
          JWT_SECRET_KEY: test-secret-key
        run: |
          cd backend
          python -m pytest \
            --cov=. \
            --cov-report=xml \
            --cov-report=html \
            --junitxml=../testing/reports/junit-backend.xml \
            --html=../testing/reports/backend-report.html \
            --maxfail=5 \
            -v

      - name: Set up Node.js
        if: needs.detect-changes.outputs.frontend == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Node.js dependencies
        if: needs.detect-changes.outputs.frontend == 'true'
        run: |
          cd frontend
          npm ci

      - name: Run frontend unit tests
        if: needs.detect-changes.outputs.frontend == 'true'
        run: |
          cd frontend
          npm run test:ci

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            testing/reports/
            backend/htmlcov/
            frontend/coverage/

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        if: always()
        with:
          files: ./backend/coverage.xml,./frontend/coverage/lcov.info
          flags: backend,frontend
          name: codecov-umbrella

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [detect-changes, unit-tests]
    if: (needs.detect-changes.outputs.backend == 'true' || github.event_name == 'workflow_dispatch' || needs.detect-changes.outputs.config == 'true') && github.event.inputs.skip_tests != 'true'
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: policycortex_integration
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install -r testing/requirements.txt

      - name: Run integration tests
        env:
          ENVIRONMENT: testing
          TESTING: true
          TEST_USE_REAL_AZURE: false
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_SQL_SERVER: localhost
          AZURE_SQL_DATABASE: policycortex_integration
          AZURE_SQL_USERNAME: test
          AZURE_SQL_PASSWORD: test
          REDIS_URL: redis://localhost:6379/1
          JWT_SECRET_KEY: test-secret-key
        run: |
          python -m pytest testing/integration/ \
            --junitxml=testing/reports/junit-integration.xml \
            --html=testing/reports/integration-report.html \
            -v

      - name: Upload integration test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: testing/reports/

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.backend == 'true' || needs.detect-changes.outputs.frontend == 'true' || github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true  # Continue if Code Security not enabled
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        continue-on-error: true  # Continue if Code Security not enabled
        with:
          languages: python, javascript

  build-images:
    name: Build Container Images
    runs-on: ubuntu-latest
    needs: [detect-changes, unit-tests]
    if: needs.detect-changes.outputs.backend == 'true' || needs.detect-changes.outputs.frontend == 'true' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch' || needs.detect-changes.outputs.config == 'true' || github.ref == 'refs/heads/main'
    
    strategy:
      matrix:
        service: 
          - api_gateway
          - azure_integration
          - ai_engine
          - data_processing
          - conversation
          - notification
          - frontend

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Get Container Registry Details
        id: acr
        run: |
          # Get the ACR details for dev environment
          ACR_NAME=$(az acr list --resource-group "rg-pcx-app-dev" --query "[0].name" -o tsv)
          ACR_LOGIN_SERVER=$(az acr show --name "$ACR_NAME" --resource-group "rg-pcx-app-dev" --query "loginServer" -o tsv)
          
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          
          echo "Using ACR: $ACR_LOGIN_SERVER"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ steps.acr.outputs.acr_login_server }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.acr.outputs.acr_login_server }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service == 'frontend' && 'frontend' || '.' }}
          file: ${{ matrix.service == 'frontend' && 'frontend/Dockerfile' || format('backend/services/{0}/Dockerfile', matrix.service) }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          build-args: |
            NODE_ENV=production
            VITE_API_BASE_URL=https://api.policycortex.com
            VITE_APP_VERSION=${{ github.sha }}

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes, security-scan]
    if: needs.detect-changes.outputs.infrastructure == 'true' || github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Register Azure Resource Providers
        run: |
          echo "Registering required Azure resource providers..."
          az provider register --namespace Microsoft.App --wait || echo "Microsoft.App registration failed, continuing..."
          az provider register --namespace Microsoft.ContainerService --wait || echo "Microsoft.ContainerService registration failed, continuing..."
          az provider register --namespace Microsoft.OperationalInsights --wait || echo "Microsoft.OperationalInsights registration failed, continuing..."
          az provider register --namespace Microsoft.ContainerRegistry --wait || echo "Microsoft.ContainerRegistry registration failed, continuing..."
          az provider register --namespace Microsoft.ManagedIdentity --wait || echo "Microsoft.ManagedIdentity registration failed, continuing..."
          az provider register --namespace Microsoft.KeyVault --wait || echo "Microsoft.KeyVault registration failed, continuing..."
          az provider register --namespace Microsoft.Cache --wait || echo "Microsoft.Cache registration failed, continuing..."
          az provider register --namespace Microsoft.Storage --wait || echo "Microsoft.Storage registration failed, continuing..."
          az provider register --namespace Microsoft.Network --wait || echo "Microsoft.Network registration failed, continuing..."
          echo "Resource provider registration completed"

      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      - name: Create resource group
        run: |
          az group create \
            --name "rg-policycortex-${{ steps.env.outputs.environment }}" \
            --location "eastus" \
            --tags Environment=${{ steps.env.outputs.environment }} Project=PolicyCortex

      - name: Deploy infrastructure
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          resourceGroupName: rg-policycortex-${{ steps.env.outputs.environment }}
          template: infrastructure/bicep/simple-infrastructure.bicep
          parameters: |
            environment=${{ steps.env.outputs.environment }}
          deploymentMode: Incremental
          deploymentName: policycortex-infrastructure-${{ github.run_number }}

      - name: Get deployment outputs
        id: deployment
        run: |
          # Get deployment outputs and store as environment variables
          DEPLOYMENT_OUTPUTS=$(az deployment group show \
            --resource-group rg-policycortex-${{ steps.env.outputs.environment }} \
            --name policycortex-infrastructure-${{ github.run_number }} \
            --query 'properties.outputs' -o json)
          
          echo "deployment_outputs<<EOF" >> $GITHUB_OUTPUT
          echo "$DEPLOYMENT_OUTPUTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  configure-environment:
    name: Configure Environment
    runs-on: self-hosted
    needs: [deploy-infrastructure, build-images]
    if: always() && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install configuration dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/requirements.txt

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Determine environment
        id: env
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            Write-Output "environment=${{ github.event.inputs.environment }}" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/main") {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/staging") {
            Write-Output "environment=staging" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          }
        shell: powershell

      - name: Generate environment configuration
        continue-on-error: true
        id: generate-config
        run: |
          try {
            python scripts/config-manager.py `
              --subscription-id ${{ secrets.AZURE_SUBSCRIPTION_ID }} `
              --environment ${{ steps.env.outputs.environment }} `
              --action generate-env `
              --output .env.${{ steps.env.outputs.environment }}
            Write-Host "✅ Environment configuration generated successfully"
          } catch {
            Write-Host "❌ Failed to generate environment configuration: $_"
            Write-Host "Creating basic fallback configuration..."
            
            # Create a basic fallback configuration file
            $configContent = "ENVIRONMENT=${{ steps.env.outputs.environment }}`n"
            $configContent += "AZURE_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}`n"
            $configContent += "AZURE_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}`n"
            $configContent += "AZURE_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}`n"
            $configContent += "AZURE_RESOURCE_GROUP=rg-pcx-app-${{ steps.env.outputs.environment }}`n"
            $configContent += "AZURE_LOCATION=eastus`n"
            $configContent | Out-File -FilePath ".env.${{ steps.env.outputs.environment }}" -Encoding UTF8
            
            Write-Host "✅ Fallback configuration created"
          }
        shell: powershell

      - name: Verify configuration file exists
        run: |
          $configFile = ".env.${{ steps.env.outputs.environment }}"
          if (Test-Path $configFile) {
            Write-Host "✅ Configuration file exists: $configFile"
            Get-Content $configFile | Write-Host
          } else {
            Write-Host "❌ Configuration file missing, creating emergency fallback..."
            $emergencyConfig = "ENVIRONMENT=${{ steps.env.outputs.environment }}`n"
            $emergencyConfig += "AZURE_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}`n"
            $emergencyConfig += "AZURE_RESOURCE_GROUP=rg-pcx-app-${{ steps.env.outputs.environment }}`n"
            $emergencyConfig | Out-File -FilePath $configFile -Encoding UTF8
          }
        shell: powershell

      - name: Upload environment configuration
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: environment-config-${{ steps.env.outputs.environment }}
          path: .env.${{ steps.env.outputs.environment }}

  deploy-services:
    name: Deploy Services
    runs-on: ubuntu-latest
    needs: [build-images, configure-environment]
    if: always() && needs.build-images.result == 'success'
    
    strategy:
      matrix:
        service:
          - api_gateway
          - azure_integration
          - ai_engine
          - data_processing
          - conversation
          - notification
          - frontend

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      - name: Get Container Registry Details
        id: acr
        run: |
          ENV=$(echo "${{ steps.env.outputs.environment }}" | head -1)
          ACR_NAME=$(az acr list --resource-group "rg-pcx-app-$ENV" --query "[0].name" -o tsv)
          ACR_LOGIN_SERVER=$(az acr show --name "$ACR_NAME" --resource-group "rg-pcx-app-$ENV" --query "loginServer" -o tsv)
          
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          
          echo "Using ACR: $ACR_LOGIN_SERVER"

      - name: Download environment configuration
        uses: actions/download-artifact@v4
        continue-on-error: true
        id: download-config
        if: needs.configure-environment.result == 'success'
        with:
          name: environment-config-${{ steps.env.outputs.environment }}
          path: ./
          
      - name: Create default environment configuration
        if: needs.configure-environment.result != 'success' || steps.download-config.outcome == 'failure'
        run: |
          echo "# Default environment configuration" > .env.${{ steps.env.outputs.environment }}
          echo "ENVIRONMENT=${{ steps.env.outputs.environment }}" >> .env.${{ steps.env.outputs.environment }}
          echo "AZURE_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> .env.${{ steps.env.outputs.environment }}
          echo "AZURE_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}" >> .env.${{ steps.env.outputs.environment }}
          echo "AZURE_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}" >> .env.${{ steps.env.outputs.environment }}
          echo "AZURE_RESOURCE_GROUP=rg-pcx-app-${{ steps.env.outputs.environment }}" >> .env.${{ steps.env.outputs.environment }}

      - name: Deploy container app
        run: |
          # Source environment configuration
          source .env.${{ steps.env.outputs.environment }}
          
          # Set default secret values (will be overridden by Key Vault if available)
          export AZURE_SQL_PASSWORD="${AZURE_SQL_PASSWORD:-development-password}"
          export AZURE_COSMOS_KEY="${AZURE_COSMOS_KEY:-development-cosmos-key}"
          export REDIS_PASSWORD="${REDIS_PASSWORD:-development-redis-password}"
          export JWT_SECRET_KEY="${JWT_SECRET_KEY:-development-jwt-secret}"
          export AZURE_OPENAI_KEY="${AZURE_OPENAI_KEY:-development-openai-key}"
          export APPLICATION_INSIGHTS_CONNECTION_STRING="${APPLICATION_INSIGHTS_CONNECTION_STRING:-InstrumentationKey=00000000-0000-0000-0000-000000000000}"
          
          # Sanitize service name for Azure Container App naming requirements
          # Replace underscores with hyphens and ensure lowercase
          SERVICE_NAME=$(echo "${{ matrix.service }}" | tr '_' '-' | tr '[:upper:]' '[:lower:]')
          CONTAINER_APP_NAME="ca-pcx-${SERVICE_NAME}-${{ steps.env.outputs.environment }}"
          
          echo "Service: ${{ matrix.service }}"
          echo "Sanitized service name: ${SERVICE_NAME}"
          echo "Container app name: ${CONTAINER_APP_NAME}"
          
          # Set default service configuration based on service type
          case "${{ matrix.service }}" in
            "api_gateway"|"frontend")
              CPU="1.0"
              MEMORY="2Gi"
              MIN_REPLICAS="2"
              MAX_REPLICAS="10"
              PORT="8000"
              ;;
            "ai_engine"|"data_processing")
              CPU="2.0"
              MEMORY="4Gi"
              MIN_REPLICAS="1"
              MAX_REPLICAS="5"
              PORT="8000"
              ;;
            *)
              CPU="0.5"
              MEMORY="1Gi"
              MIN_REPLICAS="1"
              MAX_REPLICAS="3"
              PORT="8000"
              ;;
          esac
          
          # Check if container app exists
          if az containerapp show \
            --name "${CONTAINER_APP_NAME}" \
            --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" \
            --query "name" -o tsv 2>/dev/null; then
            
            echo "Updating existing container app..."
            az containerapp update \
              --name "${CONTAINER_APP_NAME}" \
              --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" \
              --image "${{ steps.acr.outputs.acr_login_server }}/${{ matrix.service }}:${{ github.ref_name }}-${{ github.sha }}" \
              --cpu "$CPU" \
              --memory "$MEMORY" \
              --min-replicas "$MIN_REPLICAS" \
              --max-replicas "$MAX_REPLICAS" \
              --env-vars \
                ENVIRONMENT="${{ steps.env.outputs.environment }}" \
                SERVICE_NAME="${{ matrix.service }}" \
                SERVICE_PORT="$PORT" \
                AZURE_SUBSCRIPTION_ID="$AZURE_SUBSCRIPTION_ID" \
                AZURE_RESOURCE_GROUP="$AZURE_RESOURCE_GROUP" \
                AZURE_LOCATION="$AZURE_LOCATION" \
              --secrets \
                azure-sql-password="${AZURE_SQL_PASSWORD}" \
                azure-cosmos-key="${AZURE_COSMOS_KEY}" \
                redis-password="${REDIS_PASSWORD}" \
                jwt-secret-key="${JWT_SECRET_KEY}" \
                azure-openai-key="${AZURE_OPENAI_KEY}" \
                application-insights-connection-string="${APPLICATION_INSIGHTS_CONNECTION_STRING}"
          else
            echo "Creating new container app..."
            az containerapp create \
              --name "${CONTAINER_APP_NAME}" \
              --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" \
              --environment "cae-pcx-${{ steps.env.outputs.environment }}" \
              --image "${{ steps.acr.outputs.acr_login_server }}/${{ matrix.service }}:${{ github.ref_name }}-${{ github.sha }}" \
              --cpu "$CPU" \
              --memory "$MEMORY" \
              --min-replicas "$MIN_REPLICAS" \
              --max-replicas "$MAX_REPLICAS" \
              --target-port "$PORT" \
              --ingress external \
              --env-vars \
                ENVIRONMENT="${{ steps.env.outputs.environment }}" \
                SERVICE_NAME="${{ matrix.service }}" \
                SERVICE_PORT="$PORT" \
                AZURE_SUBSCRIPTION_ID="$AZURE_SUBSCRIPTION_ID" \
                AZURE_RESOURCE_GROUP="$AZURE_RESOURCE_GROUP" \
                AZURE_LOCATION="$AZURE_LOCATION" \
              --secrets \
                azure-sql-password="${AZURE_SQL_PASSWORD}" \
                azure-cosmos-key="${AZURE_COSMOS_KEY}" \
                redis-password="${REDIS_PASSWORD}" \
                jwt-secret-key="${JWT_SECRET_KEY}" \
                azure-openai-key="${AZURE_OPENAI_KEY}" \
                application-insights-connection-string="${APPLICATION_INSIGHTS_CONNECTION_STRING}"
          fi

      - name: Wait for deployment
        run: |
          echo "Waiting for container app to be ready..."
          for i in {1..60}; do
            # Use the same sanitized name as deployment
            SANITIZED_SERVICE=$(echo "${{ matrix.service }}" | tr '_' '-' | tr '[:upper:]' '[:lower:]')
            APP_NAME="ca-pcx-${SANITIZED_SERVICE}-${{ steps.env.outputs.environment }}"
            
            STATUS=$(az containerapp show \
              --name "${APP_NAME}" \
              --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" \
              --query "properties.runningStatus" -o tsv)
            
            if [[ "$STATUS" == "Running" ]]; then
              echo "Container app is running!"
              break
            fi
            
            echo "Status: $STATUS, waiting..."
            sleep 10
          done

  e2e-tests:
    name: End-to-End Tests
    runs-on: self-hosted
    needs: deploy-services
    if: always() && needs.deploy-services.result == 'success' && github.event.inputs.skip_tests != 'true'
    
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r testing/requirements.txt
          
          cd testing
          npm install playwright
          npx playwright install
        shell: powershell

      - name: Determine environment
        id: env
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            Write-Output "environment=${{ github.event.inputs.environment }}" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/main") {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/staging") {
            Write-Output "environment=staging" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          }
        shell: powershell

      - name: Get application URLs
        id: urls
        run: |
          $frontendUrl = az containerapp show `
            --name "ca-pcx-frontend-${{ steps.env.outputs.environment }}" `
            --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" `
            --query "properties.configuration.ingress.fqdn" -o tsv
          
          $apiUrl = az containerapp show `
            --name "ca-pcx-api-gateway-${{ steps.env.outputs.environment }}" `
            --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" `
            --query "properties.configuration.ingress.fqdn" -o tsv
          
          Write-Output "frontend_url=https://$frontendUrl" >> $env:GITHUB_OUTPUT
          Write-Output "api_url=https://$apiUrl" >> $env:GITHUB_OUTPUT
        shell: powershell

      - name: Run E2E tests
        env:
          FRONTEND_URL: ${{ steps.urls.outputs.frontend_url }}
          API_BASE_URL: ${{ steps.urls.outputs.api_url }}
          E2E_BROWSER: chromium
          E2E_HEADLESS: true
          TEST_USER_EMAIL: ${{ secrets.E2E_TEST_USER_EMAIL }}
          TEST_USER_PASSWORD: ${{ secrets.E2E_TEST_USER_PASSWORD }}
          RECORD_VIDEOS: true
        run: |
          python -m pytest testing/e2e/ `
            --junitxml=testing/reports/junit-e2e.xml `
            --html=testing/reports/e2e-report.html `
            -v
        shell: powershell

      - name: Upload E2E test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-test-results
          path: |
            testing/reports/
            testing/reports/videos/
            testing/reports/screenshots/

  performance-tests:
    name: Performance Tests
    runs-on: self-hosted
    needs: deploy-services
    if: always() && needs.deploy-services.result == 'success' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4

      - name: Install k6 for Windows
        run: |
          if (!(Get-Command k6 -ErrorAction SilentlyContinue)) {
            Write-Host "Installing k6..."
            $k6Url = "https://github.com/grafana/k6/releases/download/v0.47.0/k6-v0.47.0-windows-amd64.zip"
            Invoke-WebRequest -Uri $k6Url -OutFile "k6.zip"
            Expand-Archive -Path "k6.zip" -DestinationPath "."
            $env:PATH = "$PWD\k6-v0.47.0-windows-amd64;" + $env:PATH
          }
          k6 version
        shell: powershell

      - name: Determine environment
        id: env
        run: |
          if ("${{ github.ref }}" -eq "refs/heads/main") {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "environment=staging" >> $env:GITHUB_OUTPUT
          }
        shell: powershell

      - name: Get API URL
        id: url
        run: |
          $apiUrl = az containerapp show `
            --name "ca-pcx-api-gateway-${{ steps.env.outputs.environment }}" `
            --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" `
            --query "properties.configuration.ingress.fqdn" -o tsv
          
          Write-Output "api_url=https://$apiUrl" >> $env:GITHUB_OUTPUT
        shell: powershell

      - name: Run performance tests
        env:
          API_BASE_URL: ${{ steps.url.outputs.api_url }}
        run: |
          $env:PATH = "$PWD\k6-v0.47.0-windows-amd64;" + $env:PATH
          k6 run testing/performance/load-test.js `
            --out json=testing/reports/performance-results.json
        shell: powershell

      - name: Upload performance test results
        uses: actions/upload-artifact@v4
        with:
          name: performance-test-results
          path: testing/reports/performance-results.json

  deployment-validation:
    name: Deployment Validation
    runs-on: self-hosted
    needs: [deploy-services, e2e-tests]
    if: always() && needs.deploy-services.result == 'success'
    
    steps:
      - uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            Write-Output "environment=${{ github.event.inputs.environment }}" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/main") {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/staging") {
            Write-Output "environment=staging" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          }
        shell: powershell

      - name: Validate service health
        run: |
          $services = @("api-gateway", "azure-integration", "ai-engine", "data-processing", "conversation", "notification", "customer-onboarding", "frontend")
          
          foreach ($service in $services) {
            Write-Host "Checking health of $service..."
            
            $url = az containerapp show `
              --name "ca-$service-${{ steps.env.outputs.environment }}" `
              --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" `
              --query "properties.configuration.ingress.fqdn" -o tsv
            
            if ($service -eq "frontend") {
              $healthUrl = "https://$url"
              $expectedStatus = 200
            } else {
              $healthUrl = "https://$url/health"
              $expectedStatus = 200
            }
            
            Write-Host "Checking: $healthUrl"
            
            for ($i = 1; $i -le 10; $i++) {
              try {
                $response = Invoke-WebRequest -Uri $healthUrl -UseBasicParsing -TimeoutSec 30
                $statusCode = $response.StatusCode
              } catch {
                $statusCode = 0
              }
              
              if ($statusCode -eq $expectedStatus) {
                Write-Host "✅ $service is healthy (HTTP $statusCode)"
                break
              } elseif ($i -eq 10) {
                Write-Host "❌ $service health check failed after 10 attempts (HTTP $statusCode)"
                exit 1
              } else {
                Write-Host "⏳ $service not ready yet (HTTP $statusCode), retrying in 30s..."
                Start-Sleep -Seconds 30
              }
            }
          }
        shell: powershell

      - name: Validate database connectivity
        run: |
          # Test database connectivity through API Gateway
          $apiUrl = az containerapp show `
            --name "ca-pcx-api-gateway-${{ steps.env.outputs.environment }}" `
            --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" `
            --query "properties.configuration.ingress.fqdn" -o tsv
          
          try {
            $response = Invoke-RestMethod -Uri "https://$apiUrl/ready" -UseBasicParsing -TimeoutSec 30
            if ($response -like "*ready*") {
              Write-Host "✅ Database connectivity validated"
            } else {
              Write-Host "❌ Database connectivity check failed"
              Write-Host "Response: $response"
              exit 1
            }
          } catch {
            Write-Host "❌ Database connectivity check failed"
            Write-Host "Error: $_"
            exit 1
          }
        shell: powershell

      - name: Smoke test critical workflows
        run: |
          $apiUrl = az containerapp show `
            --name "ca-pcx-api-gateway-${{ steps.env.outputs.environment }}" `
            --resource-group "rg-pcx-app-${{ steps.env.outputs.environment }}" `
            --query "properties.configuration.ingress.fqdn" -o tsv
          
          # Test policy endpoint
          try {
            $policiesResponse = Invoke-RestMethod -Uri "https://$apiUrl/api/v1/policies/health" -UseBasicParsing -TimeoutSec 30
            Write-Host "✅ Policies API responding"
          } catch {
            Write-Host "❌ Policies API not responding"
            exit 1
          }
          
          # Test AI endpoint
          try {
            $aiResponse = Invoke-RestMethod -Uri "https://$apiUrl/api/v1/ai/health" -UseBasicParsing -TimeoutSec 30
            Write-Host "✅ AI API responding"
          } catch {
            Write-Host "❌ AI API not responding"
            exit 1
          }
        shell: powershell

  rollback:
    name: Rollback Deployment
    runs-on: self-hosted
    needs: [deployment-validation]
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Get previous successful deployment
        id: previous
        run: |
          # Get the previous successful deployment tag
          $previousTag = az containerapp revision list `
            --name "ca-api-gateway-prod" `
            --resource-group "rg-policycortex-prod" `
            --query "[?properties.active==``true``] | [1].properties.template.containers[0].image" `
            -o tsv | ForEach-Object { $_.Split(':')[1] }
          
          Write-Output "previous_tag=$previousTag" >> $env:GITHUB_OUTPUT
        shell: powershell

      - name: Rollback all services
        run: |
          $services = @("api-gateway", "azure-integration", "ai-engine", "data-processing", "conversation", "notification", "customer-onboarding", "frontend")
          
          foreach ($service in $services) {
            Write-Host "Rolling back $service to previous version..."
            
            az containerapp update `
              --name "ca-$service-prod" `
              --resource-group "rg-policycortex-prod" `
              --image "${{ secrets.CONTAINER_REGISTRY }}/$service:${{ steps.previous.outputs.previous_tag }}"
          }
        shell: powershell

      - name: Verify rollback
        run: |
          Write-Host "Waiting for rollback to complete..."
          Start-Sleep -Seconds 60
          
          # Verify all services are healthy after rollback
          $services = @("api-gateway", "azure-integration", "ai-engine", "data-processing", "conversation", "notification", "customer-onboarding", "frontend")
          
          foreach ($service in $services) {
            $url = az containerapp show `
              --name "ca-$service-prod" `
              --resource-group "rg-policycortex-prod" `
              --query "properties.configuration.ingress.fqdn" -o tsv
            
            if ($service -eq "frontend") {
              $healthUrl = "https://$url"
            } else {
              $healthUrl = "https://$url/health"
            }
            
            try {
              $response = Invoke-WebRequest -Uri $healthUrl -UseBasicParsing -TimeoutSec 30
              $statusCode = $response.StatusCode
            } catch {
              $statusCode = 0
            }
            
            if ($statusCode -eq 200) {
              Write-Host "✅ $service rollback successful"
            } else {
              Write-Host "❌ $service rollback failed (HTTP $statusCode)"
            }
          }
        shell: powershell

  notify:
    name: Notify Teams
    runs-on: self-hosted
    needs: [deployment-validation, rollback]
    if: always()
    
    steps:
      - name: Determine environment
        id: env
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            Write-Output "environment=${{ github.event.inputs.environment }}" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/main") {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          } elseif ("${{ github.ref }}" -eq "refs/heads/staging") {
            Write-Output "environment=staging" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "environment=dev" >> $env:GITHUB_OUTPUT
          }
        shell: powershell

      - name: Send success notification
        if: needs.deployment-validation.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            🚀 PolicyCortex deployment to ${{ steps.env.outputs.environment }} successful!
            
            📊 **Deployment Summary:**
            - Environment: ${{ steps.env.outputs.environment }}
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}
            - Tests: ${{ needs.e2e-tests.result == 'success' && '✅ Passed' || '⚠️ Skipped' }}
            
            🔗 **Links:**
            - [Pipeline Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - [Application](https://ca-frontend-${{ steps.env.outputs.environment }}.delightfulsmoke-bbe56ef9.eastus.azurecontainerapps.io)
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Send failure notification
        if: needs.deployment-validation.result == 'failure' || needs.rollback.result != 'skipped'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            🚨 PolicyCortex deployment to ${{ steps.env.outputs.environment }} failed!
            
            📊 **Deployment Summary:**
            - Environment: ${{ steps.env.outputs.environment }}
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}
            - Validation: ${{ needs.deployment-validation.result }}
            - Rollback: ${{ needs.rollback.result == 'success' && '✅ Completed' || needs.rollback.result == 'skipped' && 'N/A' || '❌ Failed' }}
            
            🔗 **Links:**
            - [Pipeline Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - [Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}