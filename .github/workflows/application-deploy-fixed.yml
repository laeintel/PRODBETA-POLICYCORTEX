name: Application Deployment

# Windows Self-Hosted Runner Compatibility:
# - Uses Git Bash (available by default on Windows runners)
# - Requires Docker Desktop installed and running
# - Requires Azure CLI installed
# - All commands compatible with Windows via Git Bash

permissions:
  contents: read
  actions: read
  security-events: write
  issues: write
  pull-requests: write

defaults:
  run:
    shell: bash

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/application-deploy-fixed.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'frontend/**'
  workflow_dispatch:  # Manual trigger
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip tests to save minutes'
        required: false
        default: true
        type: boolean
      force_deploy:
        description: 'Force deployment even on PR'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  # Combined tests to save minutes
  test-all:
    name: Run Tests (Optional)
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Test Frontend (Quick)
        working-directory: ./frontend
        run: |
          npm ci
          npm run build  # Just build, skip long tests
      
      - name: Test Backend (Quick)
        run: |
          # Just check if Python files are valid
          python -m py_compile backend/services/api_gateway/main.py
          echo "Basic syntax check passed"

  # Security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

  # Build and push all images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [test-all]
    if: always()  # Run even if tests fail
    outputs:
      acr_name: ${{ steps.get_acr.outputs.acr_name }}
      acr_login_server: ${{ steps.get_acr.outputs.acr_login_server }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get ACR Details
        id: get_acr
        run: |
          # Get ACR name with proper error handling
          ACR_NAME=$(az acr list --query "[?contains(name, 'crpcxdev')].name" -o tsv | head -n 1)
          
          # If not found, try with different pattern
          if [ -z "$ACR_NAME" ]; then
            ACR_NAME=$(az acr list --query "[?contains(name, 'pcx') && contains(name, 'dev')].name" -o tsv | head -n 1)
          fi
          
          # Final fallback
          if [ -z "$ACR_NAME" ]; then
            echo "Using default ACR name: crpcxdev"
            ACR_NAME="crpcxdev"
          fi
          
          ACR_LOGIN_SERVER="$ACR_NAME.azurecr.io"
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "Found ACR: $ACR_NAME at $ACR_LOGIN_SERVER"

      - name: Login to ACR
        run: |
          az acr login --name ${{ steps.get_acr.outputs.acr_name }}

      - name: Build and Push Backend Images
        run: |
          # Set environment variables
          export ACR_LOGIN_SERVER=${{ steps.get_acr.outputs.acr_login_server }}
          
          # Build and push each backend service
          services=("api-gateway" "azure-integration" "ai-engine" "data-processing" "conversation" "notification")
          
          for service in "${services[@]}"; do
            echo "üèóÔ∏è Building pcx-$service..."
            
            # Convert service name for directory (replace hyphens with underscores)
            service_dir=$(echo $service | sed 's/-/_/g')
            
            # Build the image
            docker build -t $ACR_LOGIN_SERVER/pcx-$service:latest \
              -t $ACR_LOGIN_SERVER/pcx-$service:${{ github.sha }} \
              -f backend/services/$service_dir/Dockerfile backend/
            
            # Push the images
            echo "üì§ Pushing pcx-$service..."
            docker push $ACR_LOGIN_SERVER/pcx-$service:latest
            docker push $ACR_LOGIN_SERVER/pcx-$service:${{ github.sha }}
            
            echo "‚úÖ Completed pcx-$service"
          done

      - name: Build and Push Frontend Image
        run: |
          # Set environment variables
          export ACR_LOGIN_SERVER=${{ steps.get_acr.outputs.acr_login_server }}
          
          echo "üèóÔ∏è Building pcx-frontend..."
          
          # Build the frontend image
          docker build -t $ACR_LOGIN_SERVER/pcx-frontend:latest \
            -t $ACR_LOGIN_SERVER/pcx-frontend:${{ github.sha }} \
            -f frontend/Dockerfile frontend/
          
          # Push the images
          echo "üì§ Pushing pcx-frontend..."
          docker push $ACR_LOGIN_SERVER/pcx-frontend:latest
          docker push $ACR_LOGIN_SERVER/pcx-frontend:${{ github.sha }}
          
          echo "‚úÖ Completed pcx-frontend"


      - name: Verify Images
        run: |
          echo "üì¶ Verifying images in ACR..."
          az acr repository list --name ${{ steps.get_acr.outputs.acr_name }} --output table
          
          # Check each service image
          services=("api-gateway" "azure-integration" "ai-engine" "data-processing" "conversation" "notification" "frontend")
          for service in "${services[@]}"; do
            echo "üè∑Ô∏è Tags for pcx-$service:"
            az acr repository show-tags --name ${{ steps.get_acr.outputs.acr_name }} --repository pcx-$service --output table || echo "No tags found for $service"
          done

  # Deploy to Development
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: always() && (github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && (github.event.inputs.force_deploy == 'true' || github.ref == 'refs/heads/main')))
    environment: dev
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Azure Resources
        id: get_resources
        run: |
          # Get resource group for dev environment - use fixed name
          RESOURCE_GROUP="rg-pcx-app-dev"
          
          # Verify it exists
          if ! az group show --name "$RESOURCE_GROUP" &>/dev/null; then
            echo "‚ùå ERROR: Resource group $RESOURCE_GROUP does not exist"
            echo "Available resource groups:"
            az group list --query "[?contains(name, 'pcx')].name" -o table
            exit 1
          fi
          
          echo "‚úÖ Using resource group: $RESOURCE_GROUP"
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          
          # Use ACR details from build-and-push job
          echo "acr_login_server=${{ needs.build-and-push.outputs.acr_login_server }}" >> $GITHUB_OUTPUT

      - name: Sync Key Vault Secrets to Container Apps
        run: |
          echo "üîê Syncing Key Vault secrets to Container Apps..."
          
          # Make the script executable
          chmod +x scripts/sync-keyvault-to-containerapp.sh
          
          # Run the sync script
          ./scripts/sync-keyvault-to-containerapp.sh dev
          
          echo "‚úÖ Key Vault secrets synced to Container Apps"

      - name: Deploy to Container Apps
        run: |
          echo "üöÄ Deploying to Container Apps with latest images and Key Vault environment variables..."
          
          # Create revision suffix with timestamp to force new revisions
          REVISION_SUFFIX="r$(date +%s)"
          echo "Using revision suffix: $REVISION_SUFFIX"
          
          # Get Container Apps Environment domain for dynamic URLs
          API_GATEWAY_FQDN=$(az containerapp show --name ca-pcx-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.configuration.ingress.fqdn" -o tsv)
          
          echo "API Gateway FQDN: $API_GATEWAY_FQDN"
          
          # Deploy each microservice using latest tags with correct container app names
          # Map service names to actual container app names and images
          declare -A service_map=(
            ["api-gateway"]="ca-pcx-gateway-dev"
            ["azure-integration"]="ca-pcx-azureint-dev"
            ["ai-engine"]="ca-pcx-ai-dev"
            ["data-processing"]="ca-pcx-dataproc-dev"
            ["conversation"]="ca-pcx-chat-dev"
            ["notification"]="ca-pcx-notify-dev"
          )
          
          for service in "${!service_map[@]}"; do
            container_app_name="${service_map[$service]}"
            echo "üì¶ Deploying $container_app_name with new revision and Key Vault secrets..."
            
            # Backend services environment variables with Key Vault secrets
            # First update the image and basic env vars
            # Try to use commit-specific image first, fallback to latest
            IMAGE_TAG="${{ github.sha }}"
            if az acr repository show-tags --name ${{ needs.build-and-push.outputs.acr_name }} --repository pcx-$service --query "[?@=='$IMAGE_TAG']" -o tsv | grep -q "$IMAGE_TAG"; then
              IMAGE_REF="${{ steps.get_resources.outputs.acr_login_server }}/pcx-$service:$IMAGE_TAG"
              echo "Using commit-specific image: $IMAGE_REF"
            else
              IMAGE_REF="${{ steps.get_resources.outputs.acr_login_server }}/pcx-$service:latest"
              echo "Using latest image: $IMAGE_REF"
            fi
            
            if az containerapp update \
              --name "$container_app_name" \
              --resource-group ${{ steps.get_resources.outputs.resource_group }} \
              --image "$IMAGE_REF" \
              --revision-suffix $REVISION_SUFFIX \
              --replace-env-vars \
                "ENVIRONMENT=dev" \
                "SERVICE_NAME=$service" \
                "SERVICE_PORT=$(case $service in api-gateway) echo 8000;; azure-integration) echo 8001;; ai-engine) echo 8002;; data-processing) echo 8003;; conversation) echo 8004;; notification) echo 8005;; *) echo 8000;; esac)" \
                "LOG_LEVEL=INFO" \
                "API_GATEWAY_URL=http://ca-pcx-gateway-dev" \
                "AZURE_INTEGRATION_URL=http://ca-pcx-azureint-dev" \
                "AI_ENGINE_URL=http://ca-pcx-ai-dev" \
                "DATA_PROCESSING_URL=http://ca-pcx-dataproc-dev" \
                "CONVERSATION_URL=http://ca-pcx-chat-dev" \
                "NOTIFICATION_URL=http://ca-pcx-notify-dev" \
              --output table; then
              echo "‚úÖ Successfully updated $container_app_name with new image"
            else
              echo "‚ùå Failed to update $container_app_name"
              exit 1
            fi
            
            # Then set the secret references using a separate command
            if az containerapp update \
              --name "$container_app_name" \
              --resource-group ${{ steps.get_resources.outputs.resource_group }} \
              --set-env-vars \
                "JWT_SECRET_KEY=secretref:jwt-secret" \
                "ENCRYPTION_KEY=secretref:encryption-key" \
                "AZURE_CLIENT_ID=secretref:azure-client-id" \
                "AZURE_TENANT_ID=secretref:azure-tenant-id" \
                "AZURE_COSMOS_ENDPOINT=secretref:cosmos-endpoint" \
                "AZURE_COSMOS_KEY=secretref:cosmos-key" \
                "REDIS_CONNECTION_STRING=secretref:redis-connection-string" \
                "AZURE_STORAGE_ACCOUNT_NAME=secretref:storage-account-name" \
                "COGNITIVE_SERVICES_KEY=secretref:cognitive-services-key" \
                "COGNITIVE_SERVICES_ENDPOINT=secretref:cognitive-services-endpoint" \
                "APPLICATION_INSIGHTS_CONNECTION_STRING=secretref:application-insights-connection-string" \
              --output table; then
              echo "‚úÖ Successfully configured secrets for $container_app_name"
            else
              echo "‚ö†Ô∏è Failed to configure secrets for $container_app_name, but continuing..."
            fi
              
            echo "‚úÖ Deployed $container_app_name with Key Vault secrets and revision suffix $REVISION_SUFFIX"
          done
          
          # Deploy Frontend
          echo "üì¶ Deploying ca-pcx-web-dev (Frontend) with new revision..."
          
          # Try to use commit-specific frontend image first, fallback to latest
          FRONTEND_TAG="${{ github.sha }}"
          if az acr repository show-tags --name ${{ needs.build-and-push.outputs.acr_name }} --repository pcx-frontend --query "[?@=='$FRONTEND_TAG']" -o tsv | grep -q "$FRONTEND_TAG"; then
            FRONTEND_IMAGE_REF="${{ steps.get_resources.outputs.acr_login_server }}/pcx-frontend:$FRONTEND_TAG"
            echo "Using commit-specific frontend image: $FRONTEND_IMAGE_REF"
          else
            FRONTEND_IMAGE_REF="${{ steps.get_resources.outputs.acr_login_server }}/pcx-frontend:latest"
            echo "Using latest frontend image: $FRONTEND_IMAGE_REF"
          fi
          
          if az containerapp update \
            --name ca-pcx-web-dev \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --image "$FRONTEND_IMAGE_REF" \
            --revision-suffix $REVISION_SUFFIX \
            --replace-env-vars \
              "VITE_API_BASE_URL=https://$API_GATEWAY_FQDN/api" \
              "VITE_APP_TITLE=PolicyCortex" \
              "VITE_ENVIRONMENT=dev" \
            --output table; then
            echo "‚úÖ Successfully deployed ca-pcx-web-dev (Frontend) with revision suffix $REVISION_SUFFIX"
          else
            echo "‚ùå Failed to deploy ca-pcx-web-dev (Frontend)"
            exit 1
          fi

      - name: Wait for deployments
        run: |
          echo "‚è≥ Waiting for Container Apps to stabilize..."
          sleep 90
          
          echo "üìä Checking deployment status and new revisions..."
          # Check the API Gateway as representative
          container_app_name="ca-pcx-gateway-dev"
          
          echo "=== $container_app_name ==="
          status=$(az containerapp show --name "$container_app_name" --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.provisioningState" -o tsv)
          echo "Provisioning State: $status"
          
          # Show latest revision
          echo "Latest revision:"
          az containerapp revision list \
            --name "$container_app_name" \
            --resource-group ${{ steps.get_resources.outputs.resource_group }} \
            --query "[0].{Name:name, CreatedTime:properties.createdTime, Active:properties.active, TrafficWeight:properties.trafficWeight}" \
            --output table
          echo ""

      - name: Run health checks
        continue-on-error: true
        run: |
          echo "ü©∫ Running comprehensive health checks..."
          
          # Get Container App URLs
          API_GATEWAY_URL=$(az containerapp show --name ca-pcx-gateway-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.configuration.ingress.fqdn" -o tsv)
          FRONTEND_URL=$(az containerapp show --name ca-pcx-web-dev --resource-group ${{ steps.get_resources.outputs.resource_group }} --query "properties.configuration.ingress.fqdn" -o tsv)
          
          echo "üåê Application URLs:"
          echo "  Frontend: https://${FRONTEND_URL}"
          echo "  API Gateway: https://${API_GATEWAY_URL}"
          
          # Define all services to health check
          declare -A health_checks=(
            ["Frontend"]="https://${FRONTEND_URL}"
            ["API Gateway"]="https://${API_GATEWAY_URL}/health"
            ["API Status"]="https://${API_GATEWAY_URL}/api/v1/status"
            ["Policies API"]="https://${API_GATEWAY_URL}/api/v1/policies"
            ["Dashboard API"]="https://${API_GATEWAY_URL}/api/v1/dashboard/overview"
          )
          
          # Health check function with retries
          check_health() {
            local url=$1
            local name=$2
            local max_attempts=10
            local wait_time=30
            
            for i in $(seq 1 $max_attempts); do
              echo "üîç Health check attempt $i/$max_attempts for $name..."
              if curl -f -m 30 "$url" > /dev/null 2>&1; then
                echo "‚úÖ $name health check passed"
                return 0
              fi
              
              if [ $i -lt $max_attempts ]; then
                echo "‚è≥ Waiting ${wait_time}s before retry..."
                sleep $wait_time
              fi
            done
            
            echo "‚ùå $name health check failed after $max_attempts attempts"
            return 1
          }
          
          # Run health checks for all services
          HEALTH_FAILED=false
          PASSED_CHECKS=0
          TOTAL_CHECKS=${#health_checks[@]}
          
          for service_name in "${!health_checks[@]}"; do
            service_url="${health_checks[$service_name]}"
            if check_health "$service_url" "$service_name"; then
              ((PASSED_CHECKS++))
            else
              HEALTH_FAILED=true
            fi
          done
          
          echo ""
          echo "üìä Health Check Summary:"
          echo "  Passed: $PASSED_CHECKS/$TOTAL_CHECKS"
          
          if [ "$HEALTH_FAILED" = "true" ]; then
            echo "‚ö†Ô∏è  Some health checks failed, but deployment was successful"
            echo "üìã Manual verification may be needed"
            echo "üåê Access your application at: https://${FRONTEND_URL}"
          else
            echo "üéâ All health checks passed!"
            echo "üåê Your application is ready at: https://${FRONTEND_URL}"
          fi

  # Deployment Summary
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-dev]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo ""
          echo "üèóÔ∏è  Build Status: ${{ needs.build-and-push.result }}"
          echo "üöÄ Deploy Status: ${{ needs.deploy-dev.result }}"
          echo ""
          echo "üè∑Ô∏è  Images Built:"
          echo "  - pcx-api-gateway:latest"
          echo "  - pcx-azure-integration:latest"
          echo "  - pcx-ai-engine:latest"
          echo "  - pcx-data-processing:latest"
          echo "  - pcx-conversation:latest"
          echo "  - pcx-notification:latest"
          echo ""
          echo "üåê ACR: ${{ needs.build-and-push.outputs.acr_login_server }}"
          echo ""
          if [ "${{ needs.deploy-dev.result }}" = "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
          else
            echo "‚ùå Deployment encountered issues. Check logs above."
          fi
          
          echo ""
          echo "üîß Pipeline Configuration:"
          echo "  - Trigger: ${{ github.event_name }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Commit: ${{ github.sha }}"
          echo "  - Environment: dev"

  # Optional: Cleanup old images to save ACR space
  cleanup-images:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-dev]
    if: always() && needs.deploy-dev.result == 'success'
    continue-on-error: true
    
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Cleanup Old Images
        run: |
          echo "üßπ Cleaning up old images to save ACR space..."
          
          ACR_NAME="${{ needs.build-and-push.outputs.acr_name }}"
          
          if [ -z "$ACR_NAME" ]; then
            echo "‚ùå ACR name not found, skipping cleanup"
            exit 0
          fi
          
          # Keep only the latest 5 tags for each repository
          services=("api-gateway" "azure-integration" "ai-engine" "data-processing" "conversation" "notification" "frontend")
          
          for service in "${services[@]}"; do
            repo_name="pcx-$service"
            echo "üóÇÔ∏è Cleaning up $repo_name..."
            
            # Get all tags sorted by creation time (newest first)
            old_tags=$(az acr repository show-tags --name "$ACR_NAME" --repository "$repo_name" \
              --query "[5:].name" -o tsv 2>/dev/null || echo "")
            
            if [ -n "$old_tags" ]; then
              echo "Found old tags to delete: $old_tags"
              for tag in $old_tags; do
                # Skip 'latest' tag
                if [ "$tag" != "latest" ]; then
                  echo "üóëÔ∏è Deleting $repo_name:$tag"
                  az acr repository delete --name "$ACR_NAME" --image "$repo_name:$tag" --yes || echo "Failed to delete $tag"
                fi
              done
            else
              echo "No old tags to clean up for $repo_name"
            fi
          done
          
          echo "‚úÖ Cleanup completed"