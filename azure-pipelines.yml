# Azure DevOps Pipeline for PolicyCortex
# Comprehensive CI/CD with testing, security scanning, and deployment

# Manual trigger only for Azure DevOps Pipeline
trigger: none

pr: none

variables:
  # Container Registry
  dockerRegistryServiceConnection: 'PolicyCortexACR'
  containerRegistry: 'policycortexacr.azurecr.io'
  
  # Build Configuration
  buildConfiguration: 'Release'
  pythonVersion: '3.11'
  nodeVersion: '18.x'
  
  # Test Configuration
  testResultsFormat: 'JUnit'
  codeCoverageFormat: 'Cobertura'
  
  # Deployment
  azureSubscription: 'PolicyCortex-Production'
  resourceGroupName: 'rg-policycortex-$(environment)'
  
  # Caching
  PYTHON_PIP_CACHE_DIR: $(Pipeline.Workspace)/.pip
  npm_config_cache: $(Pipeline.Workspace)/.npm

stages:
  # Stage 1: Build and Unit Tests
  - stage: Build
    displayName: 'Build and Unit Test'
    jobs:
      # Python Services Build
      - job: BuildBackend
        displayName: 'Build Backend Services'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          matrix:
            ApiGateway:
              serviceName: 'api_gateway'
            AzureIntegration:
              serviceName: 'azure_integration'
            AIEngine:
              serviceName: 'ai_engine'
            DataProcessing:
              serviceName: 'data_processing'
            Conversation:
              serviceName: 'conversation'
            Notification:
              serviceName: 'notification'
        
        steps:
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '$(pythonVersion)'
            displayName: 'Use Python $(pythonVersion)'

          - task: Cache@2
            inputs:
              key: 'python | "$(Agent.OS)" | backend/services/$(serviceName)/requirements.txt'
              path: $(PYTHON_PIP_CACHE_DIR)
            displayName: 'Cache pip packages'

          - script: |
              cd backend/services/$(serviceName)
              python -m pip install --upgrade pip
              # Special handling for AI Engine service with PyTorch
              if [ "$(serviceName)" = "ai_engine" ]; then
                # Two-stage installation to handle torch-geometric dependencies
                if [ -f "requirements-stage1.txt" ]; then
                  echo "Installing stage 1 requirements (including PyTorch)..."
                  pip install -r requirements-stage1.txt --index-url https://download.pytorch.org/whl/cpu
                  echo "Installing stage 2 requirements (torch-geometric packages)..."
                  pip install -r requirements-stage2.txt
                else
                  # Fallback to original requirements.txt
                  pip install -r requirements.txt
                fi
              else
                pip install -r requirements.txt
              fi
              pip install pytest pytest-cov pytest-azurepipelines
            displayName: 'Install dependencies'

          - script: |
              cd backend/services/$(serviceName)
              # Run linting
              pip install flake8 black isort
              flake8 . --max-line-length=100 --exclude=venv
              black . --check --line-length=100
              isort . --check-only --profile black
            displayName: 'Lint Python code'

          - script: |
              cd backend/services/$(serviceName)
              # Run unit tests with coverage
              pytest tests/unit -v \
                --junitxml=$(Agent.TempDirectory)/test-results-$(serviceName).xml \
                --cov=. \
                --cov-report=xml:$(Agent.TempDirectory)/coverage-$(serviceName).xml \
                --cov-report=html:$(Agent.TempDirectory)/htmlcov-$(serviceName)
            displayName: 'Run unit tests'

          - task: PublishTestResults@2
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(Agent.TempDirectory)/test-results-$(serviceName).xml'
              testRunTitle: '$(serviceName) Unit Tests'
            condition: succeededOrFailed()

          - task: PublishCodeCoverageResults@1
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/coverage-$(serviceName).xml'
              reportDirectory: '$(Agent.TempDirectory)/htmlcov-$(serviceName)'
            condition: succeededOrFailed()

          - task: Docker@2
            inputs:
              containerRegistry: '$(dockerRegistryServiceConnection)'
              repository: 'pcx-$(serviceName)'
              command: 'buildAndPush'
              Dockerfile: 'backend/services/$(serviceName)/Dockerfile'
              buildContext: 'backend'
              tags: |
                $(Build.BuildId)
                latest
            displayName: 'Build and Push Docker image'

      # Frontend Build
      - job: BuildFrontend
        displayName: 'Build Frontend'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '$(nodeVersion)'
            displayName: 'Use Node.js $(nodeVersion)'

          - task: Cache@2
            inputs:
              key: 'npm | "$(Agent.OS)" | frontend/package-lock.json'
              path: $(npm_config_cache)
            displayName: 'Cache npm packages'

          - script: |
              cd frontend
              npm ci
            displayName: 'Install dependencies'

          - script: |
              cd frontend
              npm run lint
              npm run type-check
            displayName: 'Lint and type check'

          - script: |
              cd frontend
              npm run test:unit -- --coverage
            displayName: 'Run unit tests'

          - script: |
              cd frontend
              npm run build
            displayName: 'Build frontend'

          - task: Docker@2
            inputs:
              containerRegistry: '$(dockerRegistryServiceConnection)'
              repository: 'pcx-frontend'
              command: 'buildAndPush'
              Dockerfile: 'frontend/Dockerfile'
              buildContext: 'frontend'
              tags: |
                $(Build.BuildId)
                latest
            displayName: 'Build and Push Frontend Docker image'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'frontend/dist'
              artifactName: 'frontend-dist'
            displayName: 'Publish frontend artifacts'

  # Stage 2: Integration Tests
  - stage: IntegrationTests
    displayName: 'Integration Tests'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - job: RunIntegrationTests
        displayName: 'Run Integration Tests'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - task: DockerCompose@0
            inputs:
              containerregistrytype: 'Azure Container Registry'
              azureSubscription: '$(azureSubscription)'
              azureContainerRegistry: '$(containerRegistry)'
              dockerComposeFile: 'docker-compose.test.yml'
              action: 'Run services'
              buildImages: false
            displayName: 'Start test environment'

          - script: |
              # Wait for services to be ready - check Container Apps instead of localhost
              for i in {1..30}; do
                if curl -f https://ca-api-gateway-dev.delightfulsmoke-bbe56ef9.eastus.azurecontainerapps.io/health; then
                  echo "Container Apps services are ready"
                  break
                fi
                echo "Waiting for Container Apps services... ($i/30)"
                sleep 10
              done
            displayName: 'Wait for services'

          - script: |
              # Run integration tests
              pip install pytest requests
              pytest tests/integration -v \
                --junitxml=$(Agent.TempDirectory)/integration-test-results.xml
            displayName: 'Run integration tests'

          - task: PublishTestResults@2
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(Agent.TempDirectory)/integration-test-results.xml'
              testRunTitle: 'Integration Tests'
            condition: succeededOrFailed()

          - task: DockerCompose@0
            inputs:
              containerregistrytype: 'Azure Container Registry'
              azureSubscription: '$(azureSubscription)'
              azureContainerRegistry: '$(containerRegistry)'
              dockerComposeFile: 'docker-compose.test.yml'
              action: 'Run a specific service'
              serviceName: 'logs'
              containerCommand: 'docker-compose logs > $(Agent.TempDirectory)/docker-compose.log'
            condition: failed()
            displayName: 'Collect logs on failure'

  # Stage 3: Security Scanning
  - stage: Security
    displayName: 'Security Scanning'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - job: SecurityScan
        displayName: 'Security Scanning'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - task: WhiteSource@21
            inputs:
              cwd: '$(System.DefaultWorkingDirectory)'
              projectName: 'PolicyCortex'
            displayName: 'WhiteSource scan'

          - script: |
              # Install and run OWASP dependency check
              wget https://github.com/jeremylong/DependencyCheck/releases/download/v8.4.0/dependency-check-8.4.0-release.zip
              unzip dependency-check-8.4.0-release.zip
              ./dependency-check/bin/dependency-check.sh \
                --project "PolicyCortex" \
                --scan . \
                --format "ALL" \
                --out $(Agent.TempDirectory)/dependency-check
            displayName: 'OWASP Dependency Check'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(Agent.TempDirectory)/dependency-check'
              artifactName: 'security-reports'
            displayName: 'Publish security reports'

          - script: |
              # Run Bandit for Python security
              pip install bandit
              for service in backend/services/*/; do
                echo "Scanning $service"
                bandit -r $service -f json -o $(Agent.TempDirectory)/bandit-$(basename $service).json
              done
            displayName: 'Bandit security scan'

  # Stage 4: Performance Tests
  - stage: Performance
    displayName: 'Performance Testing'
    dependsOn: IntegrationTests
    condition: succeeded()
    jobs:
      - job: LoadTesting
        displayName: 'Load Testing'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - script: |
              # Install K6
              sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
              echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
              sudo apt-get update
              sudo apt-get install k6
            displayName: 'Install K6'

          - script: |
              # Run load tests
              k6 run tests/performance/load-test.js \
                --out json=$(Agent.TempDirectory)/k6-results.json \
                --summary-export=$(Agent.TempDirectory)/k6-summary.json
            displayName: 'Run K6 load tests'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(Agent.TempDirectory)/k6-results.json'
              artifactName: 'performance-results'
            displayName: 'Publish performance results'

  # Stage 5: Deploy to Staging
  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: 
      - Security
      - Performance
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      environment: 'staging'
    
    jobs:
      - deployment: DeployToStaging
        displayName: 'Deploy to Staging'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Deploy to Azure Container Apps with proper naming
                      echo "Deploying services to staging environment"
                      
                      # Map service names to container app names
                      declare -A service_map
                      service_map["api_gateway"]="ca-pcx-gateway-staging"
                      service_map["azure_integration"]="ca-pcx-azureint-staging"
                      service_map["ai_engine"]="ca-pcx-ai-staging"
                      service_map["data_processing"]="ca-pcx-dataproc-staging"
                      service_map["conversation"]="ca-pcx-chat-staging"
                      service_map["notification"]="ca-pcx-notify-staging"
                      
                      for service in api_gateway azure_integration ai_engine data_processing conversation notification; do
                        echo "Deploying $service to ${service_map[$service]}"
                        
                        az containerapp update \
                          --name ${service_map[$service]} \
                          --resource-group $(resourceGroupName) \
                          --image $(containerRegistry)/policortex001-$service:$(Build.BuildId) \
                          --revision-suffix v$(Build.BuildId) \
                          --output none || echo "Warning: Failed to update ${service_map[$service]}"
                      done
                      
                      # Deploy frontend
                      echo "Deploying frontend to ca-pcx-web-staging"
                      az containerapp update \
                        --name ca-pcx-web-staging \
                        --resource-group $(resourceGroupName) \
                        --image $(containerRegistry)/policortex001-frontend:$(Build.BuildId) \
                        --revision-suffix v$(Build.BuildId) \
                        --output none || echo "Warning: Failed to update frontend"
                      
                      # Deploy frontend
                      az storage blob upload-batch \
                        --account-name stpolicycortexstaging \
                        --destination '$web' \
                        --source $(Pipeline.Workspace)/frontend-dist \
                        --overwrite
                  displayName: 'Deploy to Azure'

                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'scriptPath'
                    scriptPath: 'scripts/deploy-container-apps.sh'
                    arguments: 'staging $(resourceGroupName) $(Build.BuildId)'
                  displayName: 'Deploy and verify container apps'
                
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Run smoke tests if script exists
                      if [ -f "./scripts/smoke-tests.sh" ]; then
                        ./scripts/smoke-tests.sh https://ca-pcx-gateway-staging.azurecontainerapps.io
                      else
                        echo "Smoke tests script not found, skipping..."
                      fi
                  displayName: 'Run smoke tests'

  # Stage 6: Deploy to Production
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: DeployStaging
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      environment: 'production'
    
    jobs:
      - deployment: DeployToProduction
        displayName: 'Deploy to Production'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            preDeploy:
              steps:
                - script: |
                    echo "Creating backup of current production"
                    # Backup current production
                  displayName: 'Backup production'
            
            deploy:
              steps:
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Blue-Green deployment with proper naming
                      echo "Starting blue-green deployment to production"
                      
                      # Map service names to container app names
                      declare -A service_map
                      service_map["api_gateway"]="ca-pcx-gateway-prod"
                      service_map["azure_integration"]="ca-pcx-azureint-prod"
                      service_map["ai_engine"]="ca-pcx-ai-prod"
                      service_map["data_processing"]="ca-pcx-dataproc-prod"
                      service_map["conversation"]="ca-pcx-chat-prod"
                      service_map["notification"]="ca-pcx-notify-prod"
                      
                      for service in api_gateway azure_integration ai_engine data_processing conversation notification; do
                        echo "Deploying $service to ${service_map[$service]} (blue-green)"
                        
                        # Create new revision with new image
                        az containerapp update \
                          --name ${service_map[$service]} \
                          --resource-group $(resourceGroupName) \
                          --image $(containerRegistry)/policortex001-$service:$(Build.BuildId) \
                          --revision-suffix green-$(Build.BuildId) \
                          --traffic-weight latest=0
                        
                        # Test green slot
                        GREEN_URL=$(az containerapp revision show \
                          --name ca-$service-prod \
                          --resource-group $(resourceGroupName) \
                          --revision green-$(Build.BuildId) \
                          --query properties.fqdn -o tsv)
                        
                        curl -f https://$GREEN_URL/health || exit 1
                        
                        # Switch traffic to green
                        az containerapp ingress traffic set \
                          --name ca-$service-prod \
                          --resource-group $(resourceGroupName) \
                          --revision-weight green-$(Build.BuildId)=100
                      done
                  displayName: 'Blue-Green deployment'

            routeTraffic:
              steps:
                - script: |
                    echo "Monitoring deployment health"
                    # Monitor for 5 minutes
                    sleep 300
                  displayName: 'Monitor deployment'

            postRouteTraffic:
              steps:
                - script: |
                    echo "Running synthetic tests"
                    # Run synthetic user journeys
                  displayName: 'Synthetic monitoring'

            on:
              failure:
                steps:
                  - script: |
                      echo "Rolling back deployment"
                      # Rollback to previous version
                    displayName: 'Rollback on failure'
              
              success:
                steps:
                  - script: |
                      echo "Deployment successful"
                      # Clean up old revisions
                    displayName: 'Cleanup old revisions'